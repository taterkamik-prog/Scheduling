import java.io.*;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.time.temporal.TemporalAdjusters;
import java.util.*;

/*
  ============================================================
  PERSONNEL + SCHEDULING CONSOLE APP (CSV-PERSISTED)
  ============================================================

  What this program can do:
  - Build an org structure: Wing -> Group -> Squadron -> Section
  - Create employees, assign them to sections
  - Define section additional duties and assign/unassign them to employees
  - Assign rater/ratee
  - Track a schedule (events + shifts) with conflict rules
  - Track drill days + alternate drill days
  - Track traditional member availability on drill dates
  - Provide daily/weekly/monthly/hourly/shift views
  - Auto-create CSV files on first run; reload them on next run
*/

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        Store store = new Store();
        store.loadAll();

        while (true) {
            System.out.println("\n=== MAIN MENU ===");
            System.out.println("1) Organization");
            System.out.println("2) Employees");
            System.out.println("3) Additional Duties (by Section)");
            System.out.println("4) Scheduling");
            System.out.println("5) Reports");
            System.out.println("6) Save");
            System.out.println("7) Save & Exit");

            Integer choice = Input.readIntOrBack(sc, "Choice: ");
            if (choice == null) continue;

            if (choice == 1) {
                Menus.organization(sc, store);
            } else if (choice == 2) {
                Menus.employees(sc, store);
            } else if (choice == 3) {
                Menus.duties(sc, store);
            } else if (choice == 4) {
                Menus.scheduling(sc, store);
            } else if (choice == 5) {
                Menus.reports(sc, store);
            } else if (choice == 6) {
                store.saveAll();
                System.out.println("Saved.");
            } else if (choice == 7) {
                store.saveAll();
                System.out.println("Saved. Exiting.");
                break;
            } else {
                System.out.println("Invalid choice.");
            }
        }

        sc.close();
    }
}

/* ============================================================
 * INPUT HELPERS
 * ============================================================
 * All inputs are read with nextLine() to avoid Scanner newline bugs.
 * User can type:
 *   - b  to back out of the current prompt
 */
class Input {
    static final DateTimeFormatter DATE_FMT = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    static final DateTimeFormatter TIME_FMT = DateTimeFormatter.ofPattern("HH:mm");

    static String readLine(Scanner sc, String prompt) {
        System.out.print(prompt);
        return sc.nextLine();
    }

    static String readStringOrBack(Scanner sc, String prompt) {
        while (true) {
            String s = readLine(sc, prompt);
            if (s == null) return null;
            s = s.trim();
            if (s.equalsIgnoreCase("b")) return null;
            return s;
        }
    }

    static String readNonEmptyStringOrBack(Scanner sc, String prompt) {
        while (true) {
            String s = readStringOrBack(sc, prompt);
            if (s == null) return null;
            if (!s.trim().isEmpty()) return s.trim();
            System.out.println("Value cannot be blank (or type 'b' to go back).");
        }
    }

    static Integer readIntOrBack(Scanner sc, String prompt) {
        while (true) {
            String s = readStringOrBack(sc, prompt);
            if (s == null) return null;
            if (s.trim().isEmpty()) {
                System.out.println("Enter a number (or 'b' to go back).");
                continue;
            }
            try {
                return Integer.parseInt(s.trim());
            } catch (Exception ex) {
                System.out.println("Enter a valid whole number (or 'b' to go back).");
            }
        }
    }

    static LocalDate readDateOrBack(Scanner sc, String prompt) {
        while (true) {
            String s = readStringOrBack(sc, prompt);
            if (s == null) return null;
            if (s.trim().isEmpty()) {
                System.out.println("Enter a date in yyyy-MM-dd format (or 'b' to go back).");
                continue;
            }
            try {
                return LocalDate.parse(s.trim(), DATE_FMT);
            } catch (Exception ex) {
                System.out.println("Date must be yyyy-MM-dd (or 'b' to go back).");
            }
        }
    }

    static LocalTime readTimeOrBack(Scanner sc, String prompt) {
        while (true) {
            String s = readStringOrBack(sc, prompt);
            if (s == null) return null;
            if (s.trim().isEmpty()) {
                System.out.println("Enter time in HH:mm 24-hour format (or 'b' to go back).");
                continue;
            }
            try {
                return LocalTime.parse(s.trim(), TIME_FMT);
            } catch (Exception ex) {
                System.out.println("Time must be HH:mm 24-hour format (or 'b' to go back).");
            }
        }
    }

    static boolean readYesNoOrBack(Scanner sc, String prompt, boolean defaultVal) {
        while (true) {
            String s = readStringOrBack(sc, prompt + " (Y/N, b=back): ");
            if (s == null) throw new BackOutException();
            if (s.trim().isEmpty()) return defaultVal;
            if (s.equalsIgnoreCase("y") || s.equalsIgnoreCase("yes")) return true;
            if (s.equalsIgnoreCase("n") || s.equalsIgnoreCase("no")) return false;
            System.out.println("Enter Y or N (or 'b' to go back).");
        }
    }
}

class BackOutException extends RuntimeException {}

/* ============================================================
 * MENUS
 * ============================================================ */
class Menus {

    // ----------------------------
    // ORGANIZATION MENU
    // ----------------------------
    static void organization(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- ORGANIZATION ---");
            System.out.println("1) Create Wing");
            System.out.println("2) Create Group");
            System.out.println("3) Create Squadron");
            System.out.println("4) Create Section");
            System.out.println("5) Edit Wing Name");
            System.out.println("6) Edit Group Name");
            System.out.println("7) Edit Squadron Name");
            System.out.println("8) Edit Section Name");
            System.out.println("9) Delete Wing");
            System.out.println("10) Delete Group");
            System.out.println("11) Delete Squadron");
            System.out.println("12) Delete Section");
            System.out.println("13) Assign Group -> Wing");
            System.out.println("14) Assign Squadron -> Group");
            System.out.println("15) Assign Section -> Squadron");
            System.out.println("16) List All");
            System.out.println("17) Back");

            Integer c = Input.readIntOrBack(sc, "Choice: ");
            if (c == null) continue;

            if (c == 1) createWing(sc, st);
            else if (c == 2) createGroup(sc, st);
            else if (c == 3) createSquadron(sc, st);
            else if (c == 4) createSection(sc, st);
            else if (c == 5) editWing(sc, st);
            else if (c == 6) editGroup(sc, st);
            else if (c == 7) editSquadron(sc, st);
            else if (c == 8) editSection(sc, st);
            else if (c == 9) deleteWing(sc, st);
            else if (c == 10) deleteGroup(sc, st);
            else if (c == 11) deleteSquadron(sc, st);
            else if (c == 12) deleteSection(sc, st);
            else if (c == 13) assignGroupToWing(sc, st);
            else if (c == 14) assignSquadronToGroup(sc, st);
            else if (c == 15) assignSectionToSquadron(sc, st);
            else if (c == 16) listOrg(st);
            else if (c == 17) return;
            else System.out.println("Invalid choice.");
        }
    }

    // ----------------------------
    // EMPLOYEE MENU
    // ----------------------------
    static void employees(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- EMPLOYEES ---");
            System.out.println("1) Add Employee");
            System.out.println("2) Edit Employee");
            System.out.println("3) Delete Employee");
            System.out.println("4) List Employees");
            System.out.println("5) View Employee Details");
            System.out.println("6) Assign Employee to Section");
            System.out.println("7) Remove Employee from Section");
            System.out.println("8) Assign Additional Duty to Employee");
            System.out.println("9) Remove Additional Duty from Employee");
            System.out.println("10) Set/Clear Assigned Rater");
            System.out.println("11) Back");

            Integer c = Input.readIntOrBack(sc, "Choice: ");
            if (c == null) continue;

            if (c == 1) addEmployee(sc, st);
            else if (c == 2) editEmployee(sc, st);
            else if (c == 3) deleteEmployee(sc, st);
            else if (c == 4) listEmployees(st);
            else if (c == 5) viewEmployeeDetails(sc, st);
            else if (c == 6) assignEmpToSection(sc, st);
            else if (c == 7) removeEmpFromSection(sc, st);
            else if (c == 8) assignDutyToEmployee(sc, st);
            else if (c == 9) removeDutyFromEmployee(sc, st);
            else if (c == 10) setRater(sc, st);
            else if (c == 11) return;
            else System.out.println("Invalid choice.");
        }
    }

    // ----------------------------
    // DUTIES MENU
    // ----------------------------
    static void duties(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- ADDITIONAL DUTIES (BY SECTION) ---");
            System.out.println("1) View Duties for Section");
            System.out.println("2) Add Duty to Section");
            System.out.println("3) Rename Duty in Section");
            System.out.println("4) Delete Duty from Section");
            System.out.println("5) Back");

            Integer c = Input.readIntOrBack(sc, "Choice: ");
            if (c == null) continue;

            if (c == 1) viewSectionDuties(sc, st);
            else if (c == 2) addDutyToSection(sc, st);
            else if (c == 3) renameDutyInSection(sc, st);
            else if (c == 4) deleteDutyFromSection(sc, st);
            else if (c == 5) return;
            else System.out.println("Invalid choice.");
        }
    }

    // ----------------------------
    // SCHEDULING MENU
    // ----------------------------
    static void scheduling(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- SCHEDULING ---");
            System.out.println("1) Events (Create/Edit/Delete)");
            System.out.println("2) Drill Days (Create/Delete)");
            System.out.println("3) Traditional Availability (Set/View)");
            System.out.println("4) Shifts (Create/Delete/List)");
            System.out.println("5) Assign Shift to Employee (Date Range)");
            System.out.println("6) Calendar Views (Daily/Weekly/Monthly/Hourly/Shift)");
            System.out.println("7) Back");

            Integer c = Input.readIntOrBack(sc, "Choice: ");
            if (c == null) continue;

            if (c == 1) eventMenu(sc, st);
            else if (c == 2) drillMenu(sc, st);
            else if (c == 3) availabilityMenu(sc, st);
            else if (c == 4) shiftMenu(sc, st);
            else if (c == 5) assignShiftRange(sc, st);
            else if (c == 6) viewsMenu(sc, st);
            else if (c == 7) return;
            else System.out.println("Invalid choice.");
        }
    }

    // ----------------------------
    // REPORTS MENU
    // ----------------------------
    static void reports(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- REPORTS ---");
            System.out.println("1) Duty Counts (by Section)");
            System.out.println("2) Who Has a Duty (by Section + Duty)");
            System.out.println("3) Duties Assigned to an Employee");
            System.out.println("4) Rater -> Ratees");
            System.out.println("5) Availability Dashboard (by Date)");
            System.out.println("6) Back");

            Integer c = Input.readIntOrBack(sc, "Choice: ");
            if (c == null) continue;

            if (c == 1) reportDutyCounts(sc, st);
            else if (c == 2) reportWhoHasDuty(sc, st);
            else if (c == 3) reportDutiesForEmployee(sc, st);
            else if (c == 4) reportRaters(st);
            else if (c == 5) reportAvailabilityDashboard(sc, st);
            else if (c == 6) return;
            else System.out.println("Invalid choice.");
        }
    }

    // ============================================================
    // ORGANIZATION FUNCTIONS
    // ============================================================

    static void createWing(Scanner sc, Store st) {
        String id = Input.readNonEmptyStringOrBack(sc, "Wing ID: ");
        if (id == null) return;
        if (st.findWing(id) != null) { System.out.println("Wing ID exists."); return; }

        String name = Input.readNonEmptyStringOrBack(sc, "Wing Name: ");
        if (name == null) return;

        st.wings.add(new Wing(id, name));
        System.out.println("Created.");
    }

    static void createGroup(Scanner sc, Store st) {
        String id = Input.readNonEmptyStringOrBack(sc, "Group ID: ");
        if (id == null) return;
        if (st.findGroup(id) != null) { System.out.println("Group ID exists."); return; }

        String name = Input.readNonEmptyStringOrBack(sc, "Group Name: ");
        if (name == null) return;

        st.groups.add(new Group(id, name));
        System.out.println("Created.");
    }

    static void createSquadron(Scanner sc, Store st) {
        String id = Input.readNonEmptyStringOrBack(sc, "Squadron ID: ");
        if (id == null) return;
        if (st.findSquadron(id) != null) { System.out.println("Squadron ID exists."); return; }

        String name = Input.readNonEmptyStringOrBack(sc, "Squadron Name: ");
        if (name == null) return;

        st.squadrons.add(new Squadron(id, name));
        System.out.println("Created.");
    }

    static void createSection(Scanner sc, Store st) {
        String id = Input.readNonEmptyStringOrBack(sc, "Section ID: ");
        if (id == null) return;
        if (st.findSection(id) != null) { System.out.println("Section ID exists."); return; }

        String name = Input.readNonEmptyStringOrBack(sc, "Section Name: ");
        if (name == null) return;

        st.sections.add(new Section(id, name));
        System.out.println("Created.");
    }

    static void editWing(Scanner sc, Store st) {
        listWings(st);
        String id = Input.readNonEmptyStringOrBack(sc, "Wing ID: ");
        if (id == null) return;
        Wing w = st.findWing(id);
        if (w == null) { System.out.println("Wing not found."); return; }

        String newName = Input.readNonEmptyStringOrBack(sc, "New Name: ");
        if (newName == null) return;
        w.name = newName;
        System.out.println("Updated.");
    }

    static void editGroup(Scanner sc, Store st) {
        listGroups(st);
        String id = Input.readNonEmptyStringOrBack(sc, "Group ID: ");
        if (id == null) return;
        Group g = st.findGroup(id);
        if (g == null) { System.out.println("Group not found."); return; }

        String newName = Input.readNonEmptyStringOrBack(sc, "New Name: ");
        if (newName == null) return;
        g.name = newName;
        System.out.println("Updated.");
    }

    static void editSquadron(Scanner sc, Store st) {
        listSquadrons(st);
        String id = Input.readNonEmptyStringOrBack(sc, "Squadron ID: ");
        if (id == null) return;
        Squadron s = st.findSquadron(id);
        if (s == null) { System.out.println("Squadron not found."); return; }

        String newName = Input.readNonEmptyStringOrBack(sc, "New Name: ");
        if (newName == null) return;
        s.name = newName;
        System.out.println("Updated.");
    }

    static void editSection(Scanner sc, Store st) {
        listSections(st);
        String id = Input.readNonEmptyStringOrBack(sc, "Section ID: ");
        if (id == null) return;
        Section s = st.findSection(id);
        if (s == null) { System.out.println("Section not found."); return; }

        String newName = Input.readNonEmptyStringOrBack(sc, "New Name: ");
        if (newName == null) return;
        s.name = newName;
        System.out.println("Updated.");
    }

    static void deleteWing(Scanner sc, Store st) {
        listWings(st);
        String id = Input.readNonEmptyStringOrBack(sc, "Wing ID: ");
        if (id == null) return;
        Wing w = st.findWing(id);
        if (w == null) { System.out.println("Wing not found."); return; }

        for (Group g : st.groups) if (g.wingId.equalsIgnoreCase(id)) g.wingId = "";
        st.wings.remove(w);
        System.out.println("Deleted. Groups unassigned.");
    }

    static void deleteGroup(Scanner sc, Store st) {
        listGroups(st);
        String id = Input.readNonEmptyStringOrBack(sc, "Group ID: ");
        if (id == null) return;
        Group g = st.findGroup(id);
        if (g == null) { System.out.println("Group not found."); return; }

        for (Squadron sq : st.squadrons) if (sq.groupId.equalsIgnoreCase(id)) sq.groupId = "";
        st.groups.remove(g);
        System.out.println("Deleted. Squadrons unassigned.");
    }

    static void deleteSquadron(Scanner sc, Store st) {
        listSquadrons(st);
        String id = Input.readNonEmptyStringOrBack(sc, "Squadron ID: ");
        if (id == null) return;
        Squadron s = st.findSquadron(id);
        if (s == null) { System.out.println("Squadron not found."); return; }

        for (Section sec : st.sections) if (sec.squadronId.equalsIgnoreCase(id)) sec.squadronId = "";
        st.squadrons.remove(s);
        System.out.println("Deleted. Sections unassigned.");
    }

    static void deleteSection(Scanner sc, Store st) {
        listSections(st);
        String id = Input.readNonEmptyStringOrBack(sc, "Section ID: ");
        if (id == null) return;
        Section sec = st.findSection(id);
        if (sec == null) { System.out.println("Section not found."); return; }

        for (Employee e : st.employees) {
            e.sectionIds.removeIf(sid -> sid.equalsIgnoreCase(id));
            e.dutyAssignments.removeIf(a -> a.sectionId.equalsIgnoreCase(id));
        }

        st.sections.remove(sec);
        System.out.println("Deleted. Employee memberships/duties removed.");
    }

    static void assignGroupToWing(Scanner sc, Store st) {
        listGroups(st);
        String gid = Input.readNonEmptyStringOrBack(sc, "Group ID: ");
        if (gid == null) return;
        Group g = st.findGroup(gid);
        if (g == null) { System.out.println("Group not found."); return; }

        listWings(st);
        String wid = Input.readStringOrBack(sc, "Wing ID (blank to unassign): ");
        if (wid == null) return;

        if (wid.isEmpty()) { g.wingId = ""; System.out.println("Unassigned."); return; }

        Wing w = st.findWing(wid);
        if (w == null) { System.out.println("Wing not found."); return; }

        g.wingId = w.wingId;
        System.out.println("Assigned.");
    }

    static void assignSquadronToGroup(Scanner sc, Store st) {
        listSquadrons(st);
        String sid = Input.readNonEmptyStringOrBack(sc, "Squadron ID: ");
        if (sid == null) return;
        Squadron sq = st.findSquadron(sid);
        if (sq == null) { System.out.println("Squadron not found."); return; }

        listGroups(st);
        String gid = Input.readStringOrBack(sc, "Group ID (blank to unassign): ");
        if (gid == null) return;

        if (gid.isEmpty()) { sq.groupId = ""; System.out.println("Unassigned."); return; }

        Group g = st.findGroup(gid);
        if (g == null) { System.out.println("Group not found."); return; }

        sq.groupId = g.groupId;
        System.out.println("Assigned.");
    }

    static void assignSectionToSquadron(Scanner sc, Store st) {
        listSections(st);
        String secId = Input.readNonEmptyStringOrBack(sc, "Section ID: ");
        if (secId == null) return;
        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("Section not found."); return; }

        listSquadrons(st);
        String sqId = Input.readStringOrBack(sc, "Squadron ID (blank to unassign): ");
        if (sqId == null) return;

        if (sqId.isEmpty()) { sec.squadronId = ""; System.out.println("Unassigned."); return; }

        Squadron sq = st.findSquadron(sqId);
        if (sq == null) { System.out.println("Squadron not found."); return; }

        sec.squadronId = sq.squadronId;
        System.out.println("Assigned.");
    }

    static void listOrg(Store st) {
        System.out.println("\nWINGS"); listWings(st);
        System.out.println("\nGROUPS"); listGroups(st);
        System.out.println("\nSQUADRONS"); listSquadrons(st);
        System.out.println("\nSECTIONS"); listSections(st);
    }

    static void listWings(Store st) {
        if (st.wings.isEmpty()) { System.out.println("(None)"); return; }
        for (Wing w : st.wings) System.out.println(w.wingId + " | " + w.name);
    }

    static void listGroups(Store st) {
        if (st.groups.isEmpty()) { System.out.println("(None)"); return; }
        for (Group g : st.groups) {
            System.out.println(g.groupId + " | " + g.name + " | Wing: " + (g.wingId.isEmpty() ? "UNASSIGNED" : g.wingId));
        }
    }

    static void listSquadrons(Store st) {
        if (st.squadrons.isEmpty()) { System.out.println("(None)"); return; }
        for (Squadron s : st.squadrons) {
            System.out.println(s.squadronId + " | " + s.name + " | Group: " + (s.groupId.isEmpty() ? "UNASSIGNED" : s.groupId));
        }
    }

    static void listSections(Store st) {
        if (st.sections.isEmpty()) { System.out.println("(None)"); return; }
        for (Section s : st.sections) {
            System.out.println(s.sectionId + " | " + s.name + " | Squadron: " + (s.squadronId.isEmpty() ? "UNASSIGNED" : s.squadronId));
        }
    }

    // ============================================================
    // EMPLOYEES
    // ============================================================

    static void addEmployee(Scanner sc, Store st) {
        String id = Input.readNonEmptyStringOrBack(sc, "Employee ID: ");
        if (id == null) return;
        if (st.findEmployee(id) != null) { System.out.println("Employee ID exists."); return; }

        Employee e = new Employee(id);

        String empNum = Input.readStringOrBack(sc, "Employee Number (optional): ");
        if (empNum == null) return;
        e.employeeNumber = empNum;

        String imds = Input.readStringOrBack(sc, "IMDS User ID (optional): ");
        if (imds == null) return;
        e.imdsUserId = imds;

        String rank = Input.readStringOrBack(sc, "Rank: ");
        if (rank == null) return;
        e.rank = rank;

        String first = Input.readStringOrBack(sc, "First Name: ");
        if (first == null) return;
        e.firstName = first;

        String last = Input.readStringOrBack(sc, "Last Name: ");
        if (last == null) return;
        e.lastName = last;

        String type = Input.readNonEmptyStringOrBack(sc, "Employment Type (FULL_TIME/TRADITIONAL): ");
        if (type == null) return;
        try { e.type = EmploymentType.valueOf(type.trim().toUpperCase()); }
        catch (Exception ex) { System.out.println("Invalid type."); return; }

        Integer skill = Input.readIntOrBack(sc, "Skill Level (number): ");
        if (skill == null) return;
        e.skillLevel = skill;

        st.employees.add(e);
        System.out.println("Added.");
    }

    static void editEmployee(Scanner sc, Store st) {
        listEmployees(st);

        String id = Input.readNonEmptyStringOrBack(sc, "Employee ID: ");
        if (id == null) return;
        Employee e = st.findEmployee(id);
        if (e == null) { System.out.println("Employee not found."); return; }

        System.out.println("1) Employee Number");
        System.out.println("2) IMDS User ID");
        System.out.println("3) Rank");
        System.out.println("4) First Name");
        System.out.println("5) Last Name");
        System.out.println("6) Employment Type");
        System.out.println("7) Skill Level");

        Integer f = Input.readIntOrBack(sc, "Field: ");
        if (f == null) return;

        if (f == 1) { String v = Input.readStringOrBack(sc, "New Employee Number: "); if (v != null) e.employeeNumber = v; }
        else if (f == 2) { String v = Input.readStringOrBack(sc, "New IMDS User ID: "); if (v != null) e.imdsUserId = v; }
        else if (f == 3) { String v = Input.readStringOrBack(sc, "New Rank: "); if (v != null) e.rank = v; }
        else if (f == 4) { String v = Input.readStringOrBack(sc, "New First Name: "); if (v != null) e.firstName = v; }
        else if (f == 5) { String v = Input.readStringOrBack(sc, "New Last Name: "); if (v != null) e.lastName = v; }
        else if (f == 6) {
            String v = Input.readNonEmptyStringOrBack(sc, "Employment Type (FULL_TIME/TRADITIONAL): ");
            if (v == null) return;
            try { e.type = EmploymentType.valueOf(v.trim().toUpperCase()); }
            catch (Exception ex) { System.out.println("Invalid type."); return; }
        }
        else if (f == 7) { Integer v = Input.readIntOrBack(sc, "New Skill Level: "); if (v != null) e.skillLevel = v; }
        else { System.out.println("Invalid field."); return; }

        System.out.println("Updated.");
    }

    static void deleteEmployee(Scanner sc, Store st) {
        listEmployees(st);

        String id = Input.readNonEmptyStringOrBack(sc, "Employee ID: ");
        if (id == null) return;
        Employee e = st.findEmployee(id);
        if (e == null) { System.out.println("Employee not found."); return; }

        for (Employee other : st.employees) {
            if (other.raterEmployeeId.equalsIgnoreCase(id)) other.raterEmployeeId = "";
        }

        st.employees.remove(e);

        st.events.removeIf(ev -> !ev.isGlobal() && ev.employeeIdOrNull.equalsIgnoreCase(id));
        st.availability.removeIf(a -> a.employeeId.equalsIgnoreCase(id));

        System.out.println("Deleted.");
    }

    static void listEmployees(Store st) {
        System.out.println("\nEMPLOYEES");
        if (st.employees.isEmpty()) { System.out.println("(None)"); return; }
        for (Employee e : st.employees) {
            System.out.println(e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName + " | " + e.type + " | Skill " + e.skillLevel);
        }
    }

    static void viewEmployeeDetails(Scanner sc, Store st) {
        listEmployees(st);

        String id = Input.readNonEmptyStringOrBack(sc, "Employee ID: ");
        if (id == null) return;
        Employee e = st.findEmployee(id);
        if (e == null) { System.out.println("Employee not found."); return; }

        System.out.println("\nDETAILS: " + e.employeeId);
        System.out.println("Name: " + e.rank + " " + e.firstName + " " + e.lastName);
        System.out.println("Type: " + e.type);
        System.out.println("Skill: " + e.skillLevel);
        System.out.println("Employee Number: " + e.employeeNumber);
        System.out.println("IMDS User ID: " + e.imdsUserId);

        if (e.raterEmployeeId.isEmpty()) {
            System.out.println("Rater: (None)");
        } else {
            Employee r = st.findEmployee(e.raterEmployeeId);
            System.out.println("Rater: " + e.raterEmployeeId + (r == null ? " (missing record)" : " (" + r.rank + " " + r.lastName + ")"));
        }

        System.out.println("\nSections:");
        if (e.sectionIds.isEmpty()) System.out.println("(None)");
        else for (String sid : e.sectionIds) System.out.println(" - " + st.formatSectionChain(sid));

        System.out.println("\nAdditional Duties:");
        if (e.dutyAssignments.isEmpty()) System.out.println("(None)");
        else for (DutyAssign a : e.dutyAssignments) System.out.println(" - " + st.formatSectionChain(a.sectionId) + " => " + a.dutyName);
    }

    static void assignEmpToSection(Scanner sc, Store st) {
        listEmployees(st);

        String empId = Input.readNonEmptyStringOrBack(sc, "Employee ID: ");
        if (empId == null) return;
        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("Employee not found."); return; }

        listSections(st);

        String secId = Input.readNonEmptyStringOrBack(sc, "Section ID: ");
        if (secId == null) return;
        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("Section not found."); return; }

        if (st.containsIgnoreCase(e.sectionIds, secId)) { System.out.println("Already assigned."); return; }
        e.sectionIds.add(sec.sectionId);

        System.out.println("Assigned.");
    }

    static void removeEmpFromSection(Scanner sc, Store st) {
        listEmployees(st);

        String empId = Input.readNonEmptyStringOrBack(sc, "Employee ID: ");
        if (empId == null) return;
        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("Employee not found."); return; }

        if (e.sectionIds.isEmpty()) { System.out.println("Employee has no sections."); return; }

        System.out.println("Sections:");
        for (String sid : e.sectionIds) System.out.println(" - " + st.formatSectionChain(sid));

        String secId = Input.readNonEmptyStringOrBack(sc, "Section ID to remove: ");
        if (secId == null) return;

        boolean removed = e.sectionIds.removeIf(sid -> sid.equalsIgnoreCase(secId));
        e.dutyAssignments.removeIf(a -> a.sectionId.equalsIgnoreCase(secId));

        if (!removed) { System.out.println("Not a member of that section."); return; }
        System.out.println("Removed.");
    }

    static void assignDutyToEmployee(Scanner sc, Store st) {
        listEmployees(st);

        String empId = Input.readNonEmptyStringOrBack(sc, "Employee ID: ");
        if (empId == null) return;
        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("Employee not found."); return; }

        if (e.sectionIds.isEmpty()) { System.out.println("Employee has no section memberships."); return; }

        System.out.println("Employee Sections:");
        for (String sid : e.sectionIds) System.out.println(" - " + st.formatSectionChain(sid));

        String secId = Input.readNonEmptyStringOrBack(sc, "Section ID: ");
        if (secId == null) return;

        if (!st.containsIgnoreCase(e.sectionIds, secId)) { System.out.println("Employee not in that section."); return; }

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("Section not found."); return; }

        if (sec.dutyNames.isEmpty()) { System.out.println("Section has no duties."); return; }

        System.out.println("Section Duties:");
        for (String d : sec.dutyNames) System.out.println(" - " + d);

        String dutyName = Input.readNonEmptyStringOrBack(sc, "Duty Name (exact): ");
        if (dutyName == null) return;

        if (!st.sectionHasDuty(secId, dutyName)) { System.out.println("Duty not defined for that section."); return; }
        if (st.employeeHasDuty(e, secId, dutyName)) { System.out.println("Already assigned."); return; }

        e.dutyAssignments.add(new DutyAssign(sec.sectionId, dutyName));
        System.out.println("Assigned.");
    }

    static void removeDutyFromEmployee(Scanner sc, Store st) {
        listEmployees(st);

        String empId = Input.readNonEmptyStringOrBack(sc, "Employee ID: ");
        if (empId == null) return;
        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("Employee not found."); return; }

        if (e.dutyAssignments.isEmpty()) { System.out.println("No duty assignments."); return; }

        System.out.println("Current Assignments:");
        for (DutyAssign a : e.dutyAssignments) System.out.println(" - " + st.formatSectionChain(a.sectionId) + " => " + a.dutyName);

        String secId = Input.readNonEmptyStringOrBack(sc, "Section ID: ");
        if (secId == null) return;

        String dutyName = Input.readNonEmptyStringOrBack(sc, "Duty Name (exact): ");
        if (dutyName == null) return;

        boolean removed = e.dutyAssignments.removeIf(a ->
                a.sectionId.equalsIgnoreCase(secId) && a.dutyName.equalsIgnoreCase(dutyName));

        if (!removed) { System.out.println("Not assigned."); return; }
        System.out.println("Removed.");
    }

    static void setRater(Scanner sc, Store st) {
        listEmployees(st);

        String empId = Input.readNonEmptyStringOrBack(sc, "Employee ID to update: ");
        if (empId == null) return;
        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("Employee not found."); return; }

        System.out.println("Current rater: " + (e.raterEmployeeId.isEmpty() ? "(None)" : e.raterEmployeeId));
        String raterId = Input.readStringOrBack(sc, "Rater Employee ID (blank to clear): ");
        if (raterId == null) return;

        if (raterId.isEmpty()) { e.raterEmployeeId = ""; System.out.println("Updated."); return; }
        if (raterId.equalsIgnoreCase(empId)) { System.out.println("Cannot be own rater."); return; }
        if (st.findEmployee(raterId) == null) { System.out.println("Rater not found."); return; }

        e.raterEmployeeId = raterId;
        System.out.println("Updated.");
    }

    // ============================================================
    // DUTIES (SECTION DUTY LIST)
    // ============================================================

    static void viewSectionDuties(Scanner sc, Store st) {
        listSections(st);

        String secId = Input.readNonEmptyStringOrBack(sc, "Section ID: ");
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("Section not found."); return; }

        System.out.println("\nDuties for " + sec.sectionId + " (" + sec.name + ")");
        if (sec.dutyNames.isEmpty()) System.out.println("(None)");
        else for (String d : sec.dutyNames) System.out.println(" - " + d);
    }

    static void addDutyToSection(Scanner sc, Store st) {
        listSections(st);

        String secId = Input.readNonEmptyStringOrBack(sc, "Section ID: ");
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("Section not found."); return; }

        String duty = Input.readNonEmptyStringOrBack(sc, "Duty Name: ");
        if (duty == null) return;

        if (st.sectionHasDuty(secId, duty)) { System.out.println("Duty exists."); return; }

        sec.dutyNames.add(duty);
        System.out.println("Added.");
    }

    static void renameDutyInSection(Scanner sc, Store st) {
        listSections(st);

        String secId = Input.readNonEmptyStringOrBack(sc, "Section ID: ");
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("Section not found."); return; }
        if (sec.dutyNames.isEmpty()) { System.out.println("No duties to rename."); return; }

        System.out.println("Duties:");
        for (String d : sec.dutyNames) System.out.println(" - " + d);

        String oldName = Input.readNonEmptyStringOrBack(sc, "Old Duty Name (exact): ");
        if (oldName == null) return;

        if (!st.sectionHasDuty(secId, oldName)) { System.out.println("Duty not found."); return; }

        String newName = Input.readNonEmptyStringOrBack(sc, "New Duty Name: ");
        if (newName == null) return;

        if (st.sectionHasDuty(secId, newName)) { System.out.println("New duty name already exists."); return; }

        for (int i = 0; i < sec.dutyNames.size(); i++) {
            if (sec.dutyNames.get(i).equalsIgnoreCase(oldName)) { sec.dutyNames.set(i, newName); break; }
        }

        for (Employee e : st.employees) {
            for (DutyAssign a : e.dutyAssignments) {
                if (a.sectionId.equalsIgnoreCase(secId) && a.dutyName.equalsIgnoreCase(oldName)) a.dutyName = newName;
            }
        }

        System.out.println("Renamed.");
    }

    static void deleteDutyFromSection(Scanner sc, Store st) {
        listSections(st);

        String secId = Input.readNonEmptyStringOrBack(sc, "Section ID: ");
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("Section not found."); return; }
        if (sec.dutyNames.isEmpty()) { System.out.println("No duties to delete."); return; }

        System.out.println("Duties:");
        for (String d : sec.dutyNames) System.out.println(" - " + d);

        String duty = Input.readNonEmptyStringOrBack(sc, "Duty Name to delete (exact): ");
        if (duty == null) return;

        if (!st.sectionHasDuty(secId, duty)) { System.out.println("Duty not found."); return; }

        sec.dutyNames.removeIf(d -> d.equalsIgnoreCase(duty));

        for (Employee e : st.employees) {
            e.dutyAssignments.removeIf(a -> a.sectionId.equalsIgnoreCase(secId) && a.dutyName.equalsIgnoreCase(duty));
        }

        System.out.println("Deleted.");
    }

    // ============================================================
    // SCHEDULING: EVENTS
    // ============================================================

    static void eventMenu(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- EVENTS ---");
            System.out.println("1) Create Event");
            System.out.println("2) Edit Event");
            System.out.println("3) Delete Event");
            System.out.println("4) List Events (Date Range)");
            System.out.println("5) Back");

            Integer c = Input.readIntOrBack(sc, "Choice: ");
            if (c == null) continue;

            if (c == 1) createEvent(sc, st);
            else if (c == 2) editEvent(sc, st);
            else if (c == 3) deleteEvent(sc, st);
            else if (c == 4) listEventsRange(sc, st);
            else if (c == 5) return;
            else System.out.println("Invalid choice.");
        }
    }

    static void createEvent(Scanner sc, Store st) {
        System.out.println("\nEvent Types:");
        for (int i = 0; i < EventType.values().length; i++) {
            System.out.println((i + 1) + ") " + EventType.values()[i]);
        }

        Integer t = Input.readIntOrBack(sc, "Type #: ");
        if (t == null) return;
        if (t < 1 || t > EventType.values().length) { System.out.println("Invalid type."); return; }
        EventType type = EventType.values()[t - 1];

        String employeeId = Input.readStringOrBack(sc, "Employee ID (blank = global event): ");
        if (employeeId == null) return;

        if (!employeeId.isEmpty() && st.findEmployee(employeeId) == null) {
            System.out.println("Employee not found.");
            return;
        }

        String title = Input.readNonEmptyStringOrBack(sc, "Title: ");
        if (title == null) return;

        String notes = Input.readStringOrBack(sc, "Notes (optional): ");
        if (notes == null) return;

        LocalDate startDate = Input.readDateOrBack(sc, "Start Date (yyyy-MM-dd): ");
        if (startDate == null) return;

        LocalTime startTime = Input.readTimeOrBack(sc, "Start Time (HH:mm): ");
        if (startTime == null) return;

        LocalDate endDate = Input.readDateOrBack(sc, "End Date (yyyy-MM-dd): ");
        if (endDate == null) return;

        LocalTime endTime = Input.readTimeOrBack(sc, "End Time (HH:mm): ");
        if (endTime == null) return;

        LocalDateTime startDT = LocalDateTime.of(startDate, startTime);
        LocalDateTime endDT = LocalDateTime.of(endDate, endTime);

        String err = st.validateEvent(employeeId, type, startDT, endDT, null);
        if (err != null) { System.out.println(err); return; }

        CalendarEvent ev = new CalendarEvent();
        ev.eventId = st.nextEventId();
        ev.eventType = type;
        ev.title = title;
        ev.notes = notes;
        ev.startDateTime = startDT;
        ev.endDateTime = endDT;
        ev.employeeIdOrNull = employeeId.isEmpty() ? "" : employeeId;
        ev.shiftIdOrBlank = "";
        st.events.add(ev);

        System.out.println("Created: " + ev.eventId);
    }

    static void editEvent(Scanner sc, Store st) {
        listEventsShort(st);

        String eventId = Input.readNonEmptyStringOrBack(sc, "Event ID to edit: ");
        if (eventId == null) return;
        CalendarEvent ev = st.findEvent(eventId);
        if (ev == null) { System.out.println("Event not found."); return; }

        System.out.println("1) Type");
        System.out.println("2) Title");
        System.out.println("3) Notes");
        System.out.println("4) Start Date/Time");
        System.out.println("5) End Date/Time");
        System.out.println("6) Employee (blank = global)");
        System.out.println("7) Back");

        Integer f = Input.readIntOrBack(sc, "Field: ");
        if (f == null) return;
        if (f == 7) return;

        if (f == 1) {
            for (int i = 0; i < EventType.values().length; i++) System.out.println((i + 1) + ") " + EventType.values()[i]);
            Integer tt = Input.readIntOrBack(sc, "Type #: ");
            if (tt == null) return;
            if (tt < 1 || tt > EventType.values().length) { System.out.println("Invalid type."); return; }
            EventType newType = EventType.values()[tt - 1];

            String err = st.validateEvent(ev.employeeIdOrNull, newType, ev.startDateTime, ev.endDateTime, ev.eventId);
            if (err != null) { System.out.println(err); return; }
            ev.eventType = newType;
        } else if (f == 2) {
            String v = Input.readNonEmptyStringOrBack(sc, "New Title: ");
            if (v == null) return;
            ev.title = v;
        } else if (f == 3) {
            String v = Input.readStringOrBack(sc, "New Notes: ");
            if (v == null) return;
            ev.notes = v;
        } else if (f == 4) {
            LocalDate d = Input.readDateOrBack(sc, "New Start Date (yyyy-MM-dd): ");
            if (d == null) return;
            LocalTime tm = Input.readTimeOrBack(sc, "New Start Time (HH:mm): ");
            if (tm == null) return;
            LocalDateTime newStart = LocalDateTime.of(d, tm);

            String err = st.validateEvent(ev.employeeIdOrNull, ev.eventType, newStart, ev.endDateTime, ev.eventId);
            if (err != null) { System.out.println(err); return; }
            ev.startDateTime = newStart;
        } else if (f == 5) {
            LocalDate d = Input.readDateOrBack(sc, "New End Date (yyyy-MM-dd): ");
            if (d == null) return;
            LocalTime tm = Input.readTimeOrBack(sc, "New End Time (HH:mm): ");
            if (tm == null) return;
            LocalDateTime newEnd = LocalDateTime.of(d, tm);

            String err = st.validateEvent(ev.employeeIdOrNull, ev.eventType, ev.startDateTime, newEnd, ev.eventId);
            if (err != null) { System.out.println(err); return; }
            ev.endDateTime = newEnd;
        } else if (f == 6) {
            String newEmp = Input.readStringOrBack(sc, "New Employee ID (blank = global): ");
            if (newEmp == null) return;
            if (!newEmp.isEmpty() && st.findEmployee(newEmp) == null) { System.out.println("Employee not found."); return; }

            String err = st.validateEvent(newEmp, ev.eventType, ev.startDateTime, ev.endDateTime, ev.eventId);
            if (err != null) { System.out.println(err); return; }
            ev.employeeIdOrNull = newEmp;
        } else {
            System.out.println("Invalid field.");
            return;
        }

        System.out.println("Updated.");
    }

    static void deleteEvent(Scanner sc, Store st) {
        listEventsShort(st);

        String eventId = Input.readNonEmptyStringOrBack(sc, "Event ID to delete: ");
        if (eventId == null) return;
        CalendarEvent ev = st.findEvent(eventId);
        if (ev == null) { System.out.println("Event not found."); return; }

        st.events.remove(ev);
        System.out.println("Deleted.");
    }

    static void listEventsShort(Store st) {
        System.out.println("\nEVENTS");
        if (st.events.isEmpty()) { System.out.println("(None)"); return; }

        ArrayList<CalendarEvent> copy = new ArrayList<>(st.events);
        copy.sort(Comparator.comparing(a -> a.startDateTime));

        int limit = Math.min(30, copy.size());
        for (int i = 0; i < limit; i++) {
            CalendarEvent ev = copy.get(i);
            System.out.println(ev.eventId + " | " + ev.eventType + " | " +
                    ev.startDateTime + " to " + ev.endDateTime + " | " +
                    (ev.isGlobal() ? "GLOBAL" : ev.employeeIdOrNull) + " | " + ev.title);
        }
        if (copy.size() > limit) System.out.println("... (" + (copy.size() - limit) + " more)");
    }

    static void listEventsRange(Scanner sc, Store st) {
        LocalDate start = Input.readDateOrBack(sc, "Start Date (yyyy-MM-dd): ");
        if (start == null) return;
        LocalDate end = Input.readDateOrBack(sc, "End Date (yyyy-MM-dd): ");
        if (end == null) return;
        if (end.isBefore(start)) { System.out.println("End date must be on/after start."); return; }

        ArrayList<CalendarEvent> list = st.getEventsOverlapping(start.atStartOfDay(), end.atTime(23,59));
        list.sort(Comparator.comparing(a -> a.startDateTime));

        if (list.isEmpty()) { System.out.println("(No events in range)"); return; }

        for (CalendarEvent ev : list) {
            System.out.println(ev.eventId + " | " + ev.eventType + " | " +
                    ev.startDateTime + " to " + ev.endDateTime + " | " +
                    (ev.isGlobal() ? "GLOBAL" : ev.employeeIdOrNull) + " | " + ev.title);
        }
    }

    // ============================================================
    // SCHEDULING: DRILL DAYS
    // ============================================================

    static void drillMenu(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- DRILL DAYS ---");
            System.out.println("1) Create Drill Day");
            System.out.println("2) Create Alternate Drill Day");
            System.out.println("3) Delete Drill/Alternate Drill Day");
            System.out.println("4) List Drill Days (Month)");
            System.out.println("5) Back");

            Integer c = Input.readIntOrBack(sc, "Choice: ");
            if (c == null) continue;

            if (c == 1) createDrillDay(sc, st, EventType.DRILL_DAY);
            else if (c == 2) createDrillDay(sc, st, EventType.ALT_DRILL_DAY);
            else if (c == 3) deleteDrillDay(sc, st);
            else if (c == 4) listDrillDaysMonth(sc, st);
            else if (c == 5) return;
            else System.out.println("Invalid choice.");
        }
    }

    static void createDrillDay(Scanner sc, Store st, EventType type) {
        LocalDate date = Input.readDateOrBack(sc, "Date (yyyy-MM-dd): ");
        if (date == null) return;

        if (st.hasGlobalEventTypeOnDate(date, type)) { System.out.println("Already exists."); return; }

        CalendarEvent ev = new CalendarEvent();
        ev.eventId = st.nextEventId();
        ev.eventType = type;
        ev.title = (type == EventType.DRILL_DAY ? "Drill Day" : "Alternate Drill Day");
        ev.notes = "";
        ev.startDateTime = date.atStartOfDay();
        ev.endDateTime = date.atTime(23, 59);
        ev.employeeIdOrNull = "";
        ev.shiftIdOrBlank = "";
        st.events.add(ev);

        System.out.println("Created: " + ev.eventId);
    }

    static void deleteDrillDay(Scanner sc, Store st) {
        LocalDate date = Input.readDateOrBack(sc, "Date (yyyy-MM-dd): ");
        if (date == null) return;

        ArrayList<CalendarEvent> matching = new ArrayList<>();
        for (CalendarEvent ev : st.events) {
            if (ev.isGlobal() && (ev.eventType == EventType.DRILL_DAY || ev.eventType == EventType.ALT_DRILL_DAY)) {
                if (ev.startDateTime.toLocalDate().equals(date)) matching.add(ev);
            }
        }

        if (matching.isEmpty()) { System.out.println("No drill day found on that date."); return; }

        for (CalendarEvent ev : matching) st.events.remove(ev);
        st.availability.removeIf(a -> a.drillDate.equals(date));

        System.out.println("Deleted drill day records and availability for that date.");
    }

    static void listDrillDaysMonth(Scanner sc, Store st) {
        Integer year = Input.readIntOrBack(sc, "Year (e.g., 2026): ");
        if (year == null) return;
        Integer month = Input.readIntOrBack(sc, "Month (1-12): ");
        if (month == null) return;

        Month m = Month.of(Math.max(1, Math.min(12, month)));
        LocalDate first = LocalDate.of(year, m, 1);
        LocalDate last = first.with(TemporalAdjusters.lastDayOfMonth());

        LocalDate d = first;
        boolean any = false;
        while (!d.isAfter(last)) {
            boolean drill = st.hasGlobalEventTypeOnDate(d, EventType.DRILL_DAY);
            boolean alt = st.hasGlobalEventTypeOnDate(d, EventType.ALT_DRILL_DAY);
            if (drill || alt) {
                System.out.println(d + " | " + (drill ? "DRILL" : "") + (alt ? " ALT" : ""));
                any = true;
            }
            d = d.plusDays(1);
        }
        if (!any) System.out.println("(None)");
    }

    // ============================================================
    // SCHEDULING: TRADITIONAL AVAILABILITY
    // ============================================================

    static void availabilityMenu(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- TRADITIONAL AVAILABILITY ---");
            System.out.println("1) Set Availability (Traditional)");
            System.out.println("2) View Availability (Date)");
            System.out.println("3) Back");

            Integer c = Input.readIntOrBack(sc, "Choice: ");
            if (c == null) continue;

            if (c == 1) setAvailability(sc, st);
            else if (c == 2) viewAvailability(sc, st);
            else if (c == 3) return;
            else System.out.println("Invalid choice.");
        }
    }

    static void setAvailability(Scanner sc, Store st) {
        listEmployees(st);
        String empId = Input.readNonEmptyStringOrBack(sc, "Employee ID: ");
        if (empId == null) return;
        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("Employee not found."); return; }
        if (e.type != EmploymentType.TRADITIONAL) { System.out.println("Only traditional members use drill availability."); return; }

        LocalDate date = Input.readDateOrBack(sc, "Drill/Alt Drill Date (yyyy-MM-dd): ");
        if (date == null) return;

        if (!(st.hasGlobalEventTypeOnDate(date, EventType.DRILL_DAY) || st.hasGlobalEventTypeOnDate(date, EventType.ALT_DRILL_DAY))) {
            System.out.println("That date is not marked as a drill day or alternate drill day.");
            return;
        }

        boolean available;
        try {
            available = Input.readYesNoOrBack(sc, "Available", true);
        } catch (BackOutException ex) {
            return;
        }

        AvailabilityRecord ar = st.findAvailability(empId, date);
        if (ar == null) {
            ar = new AvailabilityRecord(empId, date, available);
            st.availability.add(ar);
        } else {
            ar.available = available;
        }

        System.out.println("Saved.");
    }

    static void viewAvailability(Scanner sc, Store st) {
        LocalDate date = Input.readDateOrBack(sc, "Date (yyyy-MM-dd): ");
        if (date == null) return;

        System.out.println("AVAILABLE traditionals:");
        boolean anyA = false;
        for (AvailabilityRecord a : st.availability) {
            if (a.drillDate.equals(date) && a.available) {
                Employee e = st.findEmployee(a.employeeId);
                if (e != null) {
                    System.out.println(e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName);
                    anyA = true;
                }
            }
        }
        if (!anyA) System.out.println("(None)");

        System.out.println("NOT AVAILABLE traditionals:");
        boolean anyN = false;
        for (AvailabilityRecord a : st.availability) {
            if (a.drillDate.equals(date) && !a.available) {
                Employee e = st.findEmployee(a.employeeId);
                if (e != null) {
                    System.out.println(e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName);
                    anyN = true;
                }
            }
        }
        if (!anyN) System.out.println("(None)");
    }

    // ============================================================
    // SCHEDULING: SHIFTS
    // ============================================================

    static void shiftMenu(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- SHIFTS ---");
            System.out.println("1) Create Shift Definition");
            System.out.println("2) Delete Shift Definition");
            System.out.println("3) List Shift Definitions");
            System.out.println("4) Back");

            Integer c = Input.readIntOrBack(sc, "Choice: ");
            if (c == null) continue;

            if (c == 1) createShift(sc, st);
            else if (c == 2) deleteShift(sc, st);
            else if (c == 3) listShifts(st);
            else if (c == 4) return;
            else System.out.println("Invalid choice.");
        }
    }

    static void createShift(Scanner sc, Store st) {
        String id = Input.readNonEmptyStringOrBack(sc, "Shift ID: ");
        if (id == null) return;
        if (st.findShift(id) != null) { System.out.println("Shift ID exists."); return; }

        String name = Input.readNonEmptyStringOrBack(sc, "Shift Name: ");
        if (name == null) return;

        LocalTime start = Input.readTimeOrBack(sc, "Start Time (HH:mm): ");
        if (start == null) return;

        LocalTime end = Input.readTimeOrBack(sc, "End Time (HH:mm): ");
        if (end == null) return;

        if (start.equals(end)) { System.out.println("Start and end cannot be the same."); return; }

        st.shifts.add(new ShiftDefinition(id, name, start, end));
        System.out.println("Created.");
    }

    static void deleteShift(Scanner sc, Store st) {
        listShifts(st);

        String id = Input.readNonEmptyStringOrBack(sc, "Shift ID: ");
        if (id == null) return;

        ShiftDefinition s = st.findShift(id);
        if (s == null) { System.out.println("Shift not found."); return; }

        st.shifts.remove(s);
        st.events.removeIf(ev -> ev.eventType == EventType.SHIFT && ev.shiftIdOrBlank.equalsIgnoreCase(id));

        System.out.println("Deleted shift and related shift events.");
    }

    static void listShifts(Store st) {
        System.out.println("\nSHIFT DEFINITIONS");
        if (st.shifts.isEmpty()) { System.out.println("(None)"); return; }
        for (ShiftDefinition s : st.shifts) {
            System.out.println(s.shiftId + " | " + s.shiftName + " | " +
                    s.startTime.format(Input.TIME_FMT) + "-" + s.endTime.format(Input.TIME_FMT));
        }
    }

    static void assignShiftRange(Scanner sc, Store st) {
        if (st.shifts.isEmpty()) { System.out.println("No shifts defined."); return; }

        listEmployees(st);
        String empId = Input.readNonEmptyStringOrBack(sc, "Employee ID: ");
        if (empId == null) return;
        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("Employee not found."); return; }

        listShifts(st);
        String shiftId = Input.readNonEmptyStringOrBack(sc, "Shift ID: ");
        if (shiftId == null) return;
        ShiftDefinition shift = st.findShift(shiftId);
        if (shift == null) { System.out.println("Shift not found."); return; }

        LocalDate start = Input.readDateOrBack(sc, "Start Date (yyyy-MM-dd): ");
        if (start == null) return;
        LocalDate end = Input.readDateOrBack(sc, "End Date (yyyy-MM-dd): ");
        if (end == null) return;
        if (end.isBefore(start)) { System.out.println("End date must be on/after start."); return; }

        LocalDate d = start;
        while (!d.isAfter(end)) {
            LocalDateTime sdt = LocalDateTime.of(d, shift.startTime);
            LocalDateTime edt = shift.endTime.isAfter(shift.startTime)
                    ? LocalDateTime.of(d, shift.endTime)
                    : LocalDateTime.of(d.plusDays(1), shift.endTime);

            String err = st.validateEvent(empId, EventType.SHIFT, sdt, edt, null);
            if (err != null) { System.out.println(err); return; }

            d = d.plusDays(1);
        }

        d = start;
        while (!d.isAfter(end)) {
            LocalDateTime sdt = LocalDateTime.of(d, shift.startTime);
            LocalDateTime edt = shift.endTime.isAfter(shift.startTime)
                    ? LocalDateTime.of(d, shift.endTime)
                    : LocalDateTime.of(d.plusDays(1), shift.endTime);

            CalendarEvent ev = new CalendarEvent();
            ev.eventId = st.nextEventId();
            ev.eventType = EventType.SHIFT;
            ev.title = "Shift: " + shift.shiftName;
            ev.notes = "";
            ev.startDateTime = sdt;
            ev.endDateTime = edt;
            ev.employeeIdOrNull = empId;
            ev.shiftIdOrBlank = shift.shiftId;
            st.events.add(ev);

            d = d.plusDays(1);
        }

        System.out.println("Assigned shift '" + shift.shiftName + "' from " + start + " to " + end + ".");
    }

    // ============================================================
    // SCHEDULING: VIEWS
    // ============================================================

    static void viewsMenu(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- CALENDAR VIEWS ---");
            System.out.println("1) Daily View");
            System.out.println("2) Weekly Summary");
            System.out.println("3) Monthly Markers");
            System.out.println("4) Hourly View (Employee + Day)");
            System.out.println("5) Shift View (Shift + Day)");
            System.out.println("6) Back");

            Integer c = Input.readIntOrBack(sc, "Choice: ");
            if (c == null) continue;

            if (c == 1) dailyView(sc, st);
            else if (c == 2) weeklySummary(sc, st);
            else if (c == 3) monthlyMarkers(sc, st);
            else if (c == 4) hourlyView(sc, st);
            else if (c == 5) shiftView(sc, st);
            else if (c == 6) return;
            else System.out.println("Invalid choice.");
        }
    }

    static void dailyView(Scanner sc, Store st) {
        LocalDate date = Input.readDateOrBack(sc, "Date (yyyy-MM-dd): ");
        if (date == null) return;

        st.ensureFederalHolidaysForYear(date.getYear());

        System.out.println("\n=== DAILY VIEW: " + date + " ===");

        ArrayList<CalendarEvent> globals = new ArrayList<>();
        for (CalendarEvent ev : st.getEventsOnDate(date)) if (ev.isGlobal()) globals.add(ev);
        globals.sort(Comparator.comparing(a -> a.startDateTime));

        System.out.println("Global:");
        if (globals.isEmpty()) System.out.println("(None)");
        else for (CalendarEvent ev : globals) System.out.println(ev.eventType + " | " + ev.title);

        for (Employee e : st.employees) {
            String status = st.computeEmployeeStatus(e, date);
            System.out.println("\n" + e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName + " | " + status);

            ArrayList<CalendarEvent> empEvents = st.getEmployeeEventsOnDate(e.employeeId, date);
            empEvents.sort(Comparator.comparing(a -> a.startDateTime));

            if (empEvents.isEmpty()) System.out.println("  (No events)");
            else {
                for (CalendarEvent ev : empEvents) {
                    System.out.println("  " + ev.eventType + " | " + ev.startDateTime.toLocalTime() + "-" + ev.endDateTime.toLocalTime() + " | " + ev.title + " (" + ev.eventId + ")");
                }
            }
        }
    }

    static void weeklySummary(Scanner sc, Store st) {
        LocalDate anyDate = Input.readDateOrBack(sc, "Enter a date within the week (yyyy-MM-dd): ");
        if (anyDate == null) return;

        st.ensureFederalHolidaysForYear(anyDate.getYear());

        LocalDate weekStart = anyDate.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY));
        LocalDate weekEnd = anyDate.with(TemporalAdjusters.nextOrSame(DayOfWeek.SUNDAY));

        System.out.println("\n=== WEEK: " + weekStart + " to " + weekEnd + " ===");

        LocalDate d = weekStart;
        while (!d.isAfter(weekEnd)) {
            boolean drill = st.hasGlobalEventTypeOnDate(d, EventType.DRILL_DAY);
            boolean alt = st.hasGlobalEventTypeOnDate(d, EventType.ALT_DRILL_DAY);
            boolean holiday = st.hasGlobalEventTypeOnDate(d, EventType.FEDERAL_HOLIDAY);

            int totalEmployeeEvents = 0;
            for (CalendarEvent ev : st.getEventsOnDate(d)) if (!ev.isGlobal()) totalEmployeeEvents++;

            System.out.println(d + " | Emp Events: " + totalEmployeeEvents +
                    " | " + (holiday ? "H " : "") + (drill ? "D " : "") + (alt ? "A " : ""));

            d = d.plusDays(1);
        }
    }

    static void monthlyMarkers(Scanner sc, Store st) {
        Integer year = Input.readIntOrBack(sc, "Year (e.g., 2026): ");
        if (year == null) return;
        Integer monthNum = Input.readIntOrBack(sc, "Month (1-12): ");
        if (monthNum == null) return;

        Month month = Month.of(Math.max(1, Math.min(12, monthNum)));
        st.ensureFederalHolidaysForYear(year);

        LocalDate first = LocalDate.of(year, month, 1);
        LocalDate last = first.with(TemporalAdjusters.lastDayOfMonth());

        System.out.println("\n=== " + month + " " + year + " ===");
        System.out.println("Su Mo Tu We Th Fr Sa");

        int firstDow = first.getDayOfWeek().getValue(); // Monday=1 .. Sunday=7
        int spaces = (firstDow % 7); // Sunday->0

        for (int i = 0; i < spaces; i++) System.out.print("   ");

        LocalDate d = first;
        while (!d.isAfter(last)) {
            boolean drill = st.hasGlobalEventTypeOnDate(d, EventType.DRILL_DAY);
            boolean alt = st.hasGlobalEventTypeOnDate(d, EventType.ALT_DRILL_DAY);
            boolean holiday = st.hasGlobalEventTypeOnDate(d, EventType.FEDERAL_HOLIDAY);

            String dayStr = String.format("%2d", d.getDayOfMonth());
            String marker = "";
            if (holiday) marker += "H";
            if (drill) marker += "D";
            if (alt) marker += "A";

            String out = dayStr + (marker.isEmpty() ? " " : marker);
            while (out.length() < 3) out += " ";
            System.out.print(out);

            if (d.getDayOfWeek() == DayOfWeek.SATURDAY) System.out.println();
            d = d.plusDays(1);
        }
        System.out.println("\nLegend: H=Holiday, D=Drill, A=Alt Drill");
    }

    static void hourlyView(Scanner sc, Store st) {
        listEmployees(st);
        String empId = Input.readNonEmptyStringOrBack(sc, "Employee ID: ");
        if (empId == null) return;
        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("Employee not found."); return; }

        LocalDate date = Input.readDateOrBack(sc, "Date (yyyy-MM-dd): ");
        if (date == null) return;

        ArrayList<CalendarEvent> empEvents = st.getEmployeeEventsOnDate(empId, date);
        empEvents.sort(Comparator.comparing(a -> a.startDateTime));

        System.out.println("\n=== HOURLY VIEW: " + e.rank + " " + e.lastName + ", " + e.firstName + " | " + date + " ===");
        for (int hour = 0; hour < 24; hour++) {
            LocalDateTime hStart = date.atTime(hour, 0);
            LocalDateTime hEnd = date.atTime(hour, 59);

            ArrayList<String> labels = new ArrayList<>();
            for (CalendarEvent ev : empEvents) {
                if (st.timeRangesOverlap(hStart, hEnd, ev.startDateTime, ev.endDateTime)) {
                    labels.add(ev.eventType + ":" + ev.title);
                }
            }

            String label = labels.isEmpty() ? "" : String.join(" | ", labels);
            System.out.println(String.format("%02d:00", hour) + " - " + label);
        }
    }

    static void shiftView(Scanner sc, Store st) {
        if (st.shifts.isEmpty()) { System.out.println("No shifts defined."); return; }

        listShifts(st);
        String shiftId = Input.readNonEmptyStringOrBack(sc, "Shift ID: ");
        if (shiftId == null) return;
        ShiftDefinition shift = st.findShift(shiftId);
        if (shift == null) { System.out.println("Shift not found."); return; }

        LocalDate date = Input.readDateOrBack(sc, "Date (yyyy-MM-dd): ");
        if (date == null) return;

        ArrayList<CalendarEvent> list = new ArrayList<>();
        for (CalendarEvent ev : st.getEventsOnDate(date)) {
            if (ev.eventType == EventType.SHIFT && !ev.isGlobal() && ev.shiftIdOrBlank.equalsIgnoreCase(shiftId)) {
                list.add(ev);
            }
        }
        list.sort(Comparator.comparing(a -> a.startDateTime));

        System.out.println("\n=== SHIFT VIEW: " + shift.shiftName + " | " + date + " ===");
        if (list.isEmpty()) { System.out.println("(No assignments)"); return; }

        for (CalendarEvent ev : list) {
            Employee e = st.findEmployee(ev.employeeIdOrNull);
            String who = (e == null) ? ev.employeeIdOrNull : (e.rank + " " + e.lastName + ", " + e.firstName);
            System.out.println(who + " | " + ev.startDateTime.toLocalTime() + "-" + ev.endDateTime.toLocalTime() + " | " + ev.eventId);
        }
    }

    // ============================================================
    // REPORTS
    // ============================================================

    static void reportDutyCounts(Scanner sc, Store st) {
        listSections(st);
        String secId = Input.readNonEmptyStringOrBack(sc, "Section ID: ");
        if (secId == null) return;
        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("Section not found."); return; }

        System.out.println("\nDuty Counts for " + sec.sectionId + " (" + sec.name + ")");
        if (sec.dutyNames.isEmpty()) { System.out.println("(No duties defined)"); return; }

        for (String duty : sec.dutyNames) {
            int count = 0;
            for (Employee e : st.employees) {
                if (st.employeeHasDuty(e, secId, duty)) count++;
            }
            System.out.println(duty + " | Count: " + count);
        }
    }

    static void reportWhoHasDuty(Scanner sc, Store st) {
        listSections(st);
        String secId = Input.readNonEmptyStringOrBack(sc, "Section ID: ");
        if (secId == null) return;
        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("Section not found."); return; }

        if (sec.dutyNames.isEmpty()) { System.out.println("(No duties defined)"); return; }

        System.out.println("Duties:");
        for (String d : sec.dutyNames) System.out.println(" - " + d);

        String duty = Input.readNonEmptyStringOrBack(sc, "Duty Name (exact): ");
        if (duty == null) return;
        if (!st.sectionHasDuty(secId, duty)) { System.out.println("Duty not defined."); return; }

        System.out.println("\nEmployees with duty '" + duty + "' in " + sec.sectionId + " (" + sec.name + ")");
        boolean any = false;
        for (Employee e : st.employees) {
            if (st.employeeHasDuty(e, secId, duty)) {
                System.out.println(e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName);
                any = true;
            }
        }
        if (!any) System.out.println("(None)");
    }

    static void reportDutiesForEmployee(Scanner sc, Store st) {
        listEmployees(st);
        String empId = Input.readNonEmptyStringOrBack(sc, "Employee ID: ");
        if (empId == null) return;
        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("Employee not found."); return; }

        System.out.println("\nDuties for " + e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName);
        if (e.dutyAssignments.isEmpty()) { System.out.println("(None)"); return; }

        for (DutyAssign a : e.dutyAssignments) {
            System.out.println(st.formatSectionChain(a.sectionId) + " => " + a.dutyName);
        }
    }

    static void reportRaters(Store st) {
        System.out.println("\nRater -> Ratees");
        boolean any = false;

        for (Employee rater : st.employees) {
            ArrayList<Employee> ratees = new ArrayList<>();
            for (Employee e : st.employees) {
                if (!e.raterEmployeeId.isEmpty() && e.raterEmployeeId.equalsIgnoreCase(rater.employeeId)) {
                    ratees.add(e);
                }
            }
            if (!ratees.isEmpty()) {
                System.out.println("\nRater: " + rater.employeeId + " | " + rater.rank + " " + rater.lastName + ", " + rater.firstName);
                for (Employee ratee : ratees) {
                    System.out.println("  - " + ratee.employeeId + " | " + ratee.rank + " " + ratee.lastName + ", " + ratee.firstName);
                }
                any = true;
            }
        }

        if (!any) System.out.println("(No rater assignments)");
    }

    static void reportAvailabilityDashboard(Scanner sc, Store st) {
        LocalDate date = Input.readDateOrBack(sc, "Date (yyyy-MM-dd): ");
        if (date == null) return;

        st.ensureFederalHolidaysForYear(date.getYear());

        int available = 0;
        int notAvailable = 0;

        System.out.println("\nAvailability Dashboard: " + date);
        for (Employee e : st.employees) {
            String status = st.computeEmployeeStatus(e, date);
            System.out.println(e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName + " | " + status);
            if (status.startsWith("AVAILABLE")) available++;
            else notAvailable++;
        }

        System.out.println("\nTotals: AVAILABLE=" + available + " | NOT AVAILABLE=" + notAvailable);
    }
}

/* ============================================================
 * ENUMS
 * ============================================================ */
enum EmploymentType { FULL_TIME, TRADITIONAL }

enum EventType {
    SHIFT,
    APPOINTMENT,
    TRAINING,
    TDY,
    DEPLOYMENT,
    ORDERS,
    LEAVE,
    IN_PROCESSING,
    OUT_PROCESSING,
    NIGHT_FLYING,
    DRILL_DAY,
    ALT_DRILL_DAY,
    FEDERAL_HOLIDAY,
    IN_LIEU_HOLIDAY
}

/* ============================================================
 * ORGANIZATION DATA CLASSES
 * ============================================================ */
class Wing {
    String wingId;
    String name;
    Wing(String id, String name) { this.wingId = id; this.name = name; }
}

class Group {
    String groupId;
    String name;
    String wingId = "";
    Group(String id, String name) { this.groupId = id; this.name = name; }
}

class Squadron {
    String squadronId;
    String name;
    String groupId = "";
    Squadron(String id, String name) { this.squadronId = id; this.name = name; }
}

class Section {
    String sectionId;
    String name;
    String squadronId = "";
    ArrayList<String> dutyNames = new ArrayList<>();
    Section(String id, String name) { this.sectionId = id; this.name = name; }
}

/* ============================================================
 * EMPLOYEE + DUTY ASSIGNMENT DATA CLASSES
 * ============================================================ */
class DutyAssign {
    String sectionId;
    String dutyName;
    DutyAssign(String s, String d) { sectionId = s; dutyName = d; }
}

class Employee {
    String employeeId;
    String employeeNumber = "";
    String imdsUserId = "";
    String rank = "";
    String firstName = "";
    String lastName = "";
    EmploymentType type = EmploymentType.FULL_TIME;
    int skillLevel = 0;

    String raterEmployeeId = "";
    ArrayList<String> sectionIds = new ArrayList<>();
    ArrayList<DutyAssign> dutyAssignments = new ArrayList<>();

    Employee(String id) { employeeId = id; }
}

/* ============================================================
 * SCHEDULING DATA CLASSES
 * ============================================================ */
class ShiftDefinition {
    String shiftId;
    String shiftName;
    LocalTime startTime;
    LocalTime endTime;

    ShiftDefinition(String id, String name, LocalTime start, LocalTime end) {
        shiftId = id;
        shiftName = name;
        startTime = start;
        endTime = end;
    }
}

class CalendarEvent {
    String eventId = "";
    EventType eventType = EventType.APPOINTMENT;
    String title = "";
    String notes = "";
    LocalDateTime startDateTime = LocalDateTime.now();
    LocalDateTime endDateTime = LocalDateTime.now().plusHours(1);

    // Blank means global.
    String employeeIdOrNull = "";

    // Used for SHIFT events to connect them to a shift definition.
    String shiftIdOrBlank = "";

    boolean isGlobal() { return employeeIdOrNull == null || employeeIdOrNull.trim().isEmpty(); }
}

class AvailabilityRecord {
    String employeeId;
    LocalDate drillDate;
    boolean available;

    AvailabilityRecord(String empId, LocalDate date, boolean avail) {
        employeeId = empId;
        drillDate = date;
        available = avail;
    }
}

/* ============================================================
 * STORE + CSV PERSISTENCE
 * ============================================================ */
class Store {

    ArrayList<Wing> wings = new ArrayList<>();
    ArrayList<Group> groups = new ArrayList<>();
    ArrayList<Squadron> squadrons = new ArrayList<>();
    ArrayList<Section> sections = new ArrayList<>();
    ArrayList<Employee> employees = new ArrayList<>();

    ArrayList<ShiftDefinition> shifts = new ArrayList<>();
    ArrayList<CalendarEvent> events = new ArrayList<>();
    ArrayList<AvailabilityRecord> availability = new ArrayList<>();

    final String WINGS_FILE = "wings.csv";
    final String GROUPS_FILE = "groups.csv";
    final String SQUADS_FILE = "squadrons.csv";
    final String SECTS_FILE = "sections.csv";
    final String EMPS_FILE = "employees.csv";
    final String SHIFTS_FILE = "shifts.csv";
    final String EVENTS_FILE = "events.csv";
    final String AVAIL_FILE = "availability.csv";

    int nextEventNumber = 1;

    Wing findWing(String id) { for (Wing w : wings) if (w.wingId.equalsIgnoreCase(id)) return w; return null; }
    Group findGroup(String id) { for (Group g : groups) if (g.groupId.equalsIgnoreCase(id)) return g; return null; }
    Squadron findSquadron(String id) { for (Squadron s : squadrons) if (s.squadronId.equalsIgnoreCase(id)) return s; return null; }
    Section findSection(String id) { for (Section s : sections) if (s.sectionId.equalsIgnoreCase(id)) return s; return null; }
    Employee findEmployee(String id) { for (Employee e : employees) if (e.employeeId.equalsIgnoreCase(id)) return e; return null; }
    ShiftDefinition findShift(String id) { for (ShiftDefinition s : shifts) if (s.shiftId.equalsIgnoreCase(id)) return s; return null; }
    CalendarEvent findEvent(String eventId) { for (CalendarEvent e : events) if (e.eventId.equalsIgnoreCase(eventId)) return e; return null; }

    AvailabilityRecord findAvailability(String employeeId, LocalDate date) {
        for (AvailabilityRecord a : availability) {
            if (a.employeeId.equalsIgnoreCase(employeeId) && a.drillDate.equals(date)) return a;
        }
        return null;
    }

    boolean containsIgnoreCase(List<String> list, String value) {
        for (String s : list) if (s.equalsIgnoreCase(value)) return true;
        return false;
    }

    boolean sectionHasDuty(String sectionId, String dutyName) {
        Section sec = findSection(sectionId);
        if (sec == null) return false;
        for (String d : sec.dutyNames) if (d.equalsIgnoreCase(dutyName)) return true;
        return false;
    }

    boolean employeeHasDuty(Employee e, String sectionId, String dutyName) {
        for (DutyAssign a : e.dutyAssignments) {
            if (a.sectionId.equalsIgnoreCase(sectionId) && a.dutyName.equalsIgnoreCase(dutyName)) return true;
        }
        return false;
    }

    String formatSectionChain(String sectionId) {
        Section sec = findSection(sectionId);
        if (sec == null) return sectionId + " (missing section record)";

        String squadPart = "UNASSIGNED";
        String groupPart = "UNASSIGNED";
        String wingPart = "UNASSIGNED";

        if (!sec.squadronId.isEmpty()) {
            Squadron sq = findSquadron(sec.squadronId);
            if (sq != null) {
                squadPart = sq.squadronId + " " + sq.name;

                if (!sq.groupId.isEmpty()) {
                    Group g = findGroup(sq.groupId);
                    if (g != null) {
                        groupPart = g.groupId + " " + g.name;

                        if (!g.wingId.isEmpty()) {
                            Wing w = findWing(g.wingId);
                            if (w != null) wingPart = w.wingId + " " + w.name;
                        }
                    }
                }
            }
        }

        return sec.sectionId + " " + sec.name + " | Sq: " + squadPart + " | Gp: " + groupPart + " | Wg: " + wingPart;
    }

    // ============================================================
    // LOAD/SAVE
    // ============================================================

    void loadAll() {
        ensureFileExists(WINGS_FILE);
        ensureFileExists(GROUPS_FILE);
        ensureFileExists(SQUADS_FILE);
        ensureFileExists(SECTS_FILE);
        ensureFileExists(EMPS_FILE);
        ensureFileExists(SHIFTS_FILE);
        ensureFileExists(EVENTS_FILE);
        ensureFileExists(AVAIL_FILE);

        loadWings();
        loadGroups();
        loadSquads();
        loadSects();
        loadEmps();
        loadShifts();
        loadEvents();
        loadAvailability();

        reconcile();
        updateNextEventIdCounter();

        int year = LocalDate.now().getYear();
        ensureFederalHolidaysForYear(year);
        ensureFederalHolidaysForYear(year + 1);
    }

    void saveAll() {
        saveWings();
        saveGroups();
        saveSquads();
        saveSects();
        saveEmps();
        saveShifts();
        saveEvents();
        saveAvailability();
    }

    void ensureFileExists(String file) {
        try {
            File f = new File(file);
            if (!f.exists()) {
                try (BufferedWriter bw = new BufferedWriter(new FileWriter(f))) {
                    bw.write("");
                }
            }
        } catch (Exception ex) {
            System.out.println("Could not create file: " + file);
        }
    }

    // ============================================================
    // CSV CLEANING
    // ============================================================

    static String clean(String s) {
        if (s == null) return "";
        String t = s.trim();
        t = t.replace("\n", " ").replace("\r", " ");
        t = t.replace(",", " ");
        t = t.replace("|", "/");
        t = t.replace(":", "/");
        return t;
    }

    static String joinPipe(List<String> list) {
        if (list == null || list.isEmpty()) return "";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < list.size(); i++) {
            sb.append(clean(list.get(i)));
            if (i < list.size() - 1) sb.append("|");
        }
        return sb.toString();
    }

    static ArrayList<String> splitPipe(String s) {
        ArrayList<String> out = new ArrayList<>();
        if (s == null) return out;
        String t = s.trim();
        if (t.isEmpty()) return out;

        String[] parts = t.split("\\|", -1);
        for (String p : parts) {
            String v = p.trim();
            if (!v.isEmpty()) out.add(v);
        }
        return out;
    }

    static String encodeDutyAssign(List<DutyAssign> list) {
        if (list == null || list.isEmpty()) return "";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < list.size(); i++) {
            DutyAssign a = list.get(i);
            sb.append(clean(a.sectionId)).append(":").append(clean(a.dutyName));
            if (i < list.size() - 1) sb.append("|");
        }
        return sb.toString();
    }

    static ArrayList<DutyAssign> decodeDutyAssign(String s) {
        ArrayList<DutyAssign> out = new ArrayList<>();
        if (s == null) return out;
        String t = s.trim();
        if (t.isEmpty()) return out;

        String[] parts = t.split("\\|", -1);
        for (String item : parts) {
            String x = item.trim();
            if (x.isEmpty()) continue;

            String[] kv = x.split(":", -1);
            if (kv.length >= 2) {
                String secId = kv[0].trim();
                String duty = kv[1].trim();
                if (!secId.isEmpty() && !duty.isEmpty()) out.add(new DutyAssign(secId, duty));
            }
        }
        return out;
    }

    // ============================================================
    // RECONCILE
    // ============================================================

    void reconcile() {
        for (Employee e : employees) {
            e.sectionIds.removeIf(sid -> findSection(sid) == null);
            e.dutyAssignments.removeIf(a -> findSection(a.sectionId) == null);
            e.dutyAssignments.removeIf(a -> !containsIgnoreCase(e.sectionIds, a.sectionId));
            e.dutyAssignments.removeIf(a -> !sectionHasDuty(a.sectionId, a.dutyName));

            if (!e.raterEmployeeId.isEmpty() && findEmployee(e.raterEmployeeId) == null) e.raterEmployeeId = "";
            if (e.raterEmployeeId.equalsIgnoreCase(e.employeeId)) e.raterEmployeeId = "";
        }

        events.removeIf(ev -> !ev.isGlobal() && findEmployee(ev.employeeIdOrNull) == null);
        events.removeIf(ev -> ev.eventType == EventType.SHIFT && !ev.shiftIdOrBlank.isEmpty() && findShift(ev.shiftIdOrBlank) == null);

        availability.removeIf(a -> findEmployee(a.employeeId) == null);
    }

    // ============================================================
    // CSV IO
    // ============================================================

    ArrayList<String[]> readCsv(String file) {
        ArrayList<String[]> rows = new ArrayList<>();
        try (BufferedReader br = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = br.readLine()) != null) {
                if (line.trim().isEmpty()) continue;
                String[] p = line.split(",", -1);
                for (int i = 0; i < p.length; i++) p[i] = p[i].trim();
                rows.add(p);
            }
        } catch (Exception ex) {
            System.out.println("Could not load " + file + ".");
        }
        return rows;
    }

    void writeCsv(String file, ArrayList<String[]> rows) {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(file))) {
            for (String[] r : rows) {
                for (int i = 0; i < r.length; i++) {
                    bw.write(clean(r[i]));
                    if (i < r.length - 1) bw.write(",");
                }
                bw.newLine();
            }
        } catch (Exception ex) {
            System.out.println("Could not save " + file + ".");
        }
    }

    // ============================================================
    // LOADERS
    // ============================================================

    void loadWings() {
        wings.clear();
        for (String[] p : readCsv(WINGS_FILE)) if (p.length >= 2) wings.add(new Wing(p[0], p[1]));
    }

    void loadGroups() {
        groups.clear();
        for (String[] p : readCsv(GROUPS_FILE)) {
            if (p.length >= 2) {
                Group g = new Group(p[0], p[1]);
                if (p.length >= 3) g.wingId = p[2];
                groups.add(g);
            }
        }
    }

    void loadSquads() {
        squadrons.clear();
        for (String[] p : readCsv(SQUADS_FILE)) {
            if (p.length >= 2) {
                Squadron s = new Squadron(p[0], p[1]);
                if (p.length >= 3) s.groupId = p[2];
                squadrons.add(s);
            }
        }
    }

    void loadSects() {
        sections.clear();
        for (String[] p : readCsv(SECTS_FILE)) {
            if (p.length >= 2) {
                Section s = new Section(p[0], p[1]);
                if (p.length >= 3) s.squadronId = p[2];
                if (p.length >= 4) s.dutyNames = splitPipe(p[3]);
                sections.add(s);
            }
        }
    }

    void loadEmps() {
        employees.clear();
        for (String[] p : readCsv(EMPS_FILE)) {
            if (p.length >= 7) {
                Employee e = new Employee(p[0]);
                e.employeeNumber = p[1];
                e.imdsUserId = p[2];
                e.rank = p[3];
                e.firstName = p[4];
                e.lastName = p[5];
                try { e.type = EmploymentType.valueOf(p[6]); } catch (Exception ex) { e.type = EmploymentType.FULL_TIME; }
                if (p.length >= 8) { try { e.skillLevel = Integer.parseInt(p[7]); } catch (Exception ex) { e.skillLevel = 0; } }
                if (p.length >= 9) e.raterEmployeeId = p[8];
                if (p.length >= 10) e.sectionIds = splitPipe(p[9]);
                if (p.length >= 11) e.dutyAssignments = decodeDutyAssign(p[10]);
                employees.add(e);
            }
        }
    }

    void loadShifts() {
        shifts.clear();
        for (String[] p : readCsv(SHIFTS_FILE)) {
            if (p.length >= 4) {
                try {
                    LocalTime start = LocalTime.parse(p[2], Input.TIME_FMT);
                    LocalTime end = LocalTime.parse(p[3], Input.TIME_FMT);
                    shifts.add(new ShiftDefinition(p[0], p[1], start, end));
                } catch (Exception ex) {
                    // skip invalid lines
                }
            }
        }
    }

    void loadEvents() {
        events.clear();
        DateTimeFormatter dt = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        for (String[] p : readCsv(EVENTS_FILE)) {
            if (p.length >= 7) {
                try {
                    CalendarEvent ev = new CalendarEvent();
                    ev.eventId = p[0];
                    ev.eventType = EventType.valueOf(p[1]);
                    ev.title = p[2];
                    ev.notes = p[3];
                    ev.startDateTime = LocalDateTime.parse(p[4], dt);
                    ev.endDateTime = LocalDateTime.parse(p[5], dt);
                    ev.employeeIdOrNull = p[6];
                    if (p.length >= 8) ev.shiftIdOrBlank = p[7];
                    events.add(ev);
                } catch (Exception ex) {
                    // skip invalid line
                }
            }
        }
    }

    void loadAvailability() {
        availability.clear();
        DateTimeFormatter d = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        for (String[] p : readCsv(AVAIL_FILE)) {
            if (p.length >= 3) {
                try {
                    String empId = p[0];
                    LocalDate date = LocalDate.parse(p[1], d);
                    boolean avail = p[2].equalsIgnoreCase("true") || p[2].equalsIgnoreCase("y") || p[2].equalsIgnoreCase("yes");
                    availability.add(new AvailabilityRecord(empId, date, avail));
                } catch (Exception ex) {
                    // skip invalid line
                }
            }
        }
    }

    // ============================================================
    // SAVERS
    // ============================================================

    void saveWings() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (Wing w : wings) rows.add(new String[]{w.wingId, w.name});
        writeCsv(WINGS_FILE, rows);
    }

    void saveGroups() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (Group g : groups) rows.add(new String[]{g.groupId, g.name, g.wingId});
        writeCsv(GROUPS_FILE, rows);
    }

    void saveSquads() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (Squadron s : squadrons) rows.add(new String[]{s.squadronId, s.name, s.groupId});
        writeCsv(SQUADS_FILE, rows);
    }

    void saveSects() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (Section s : sections) rows.add(new String[]{s.sectionId, s.name, s.squadronId, joinPipe(s.dutyNames)});
        writeCsv(SECTS_FILE, rows);
    }

    void saveEmps() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (Employee e : employees) {
            rows.add(new String[]{
                    e.employeeId,
                    e.employeeNumber,
                    e.imdsUserId,
                    e.rank,
                    e.firstName,
                    e.lastName,
                    e.type.toString(),
                    String.valueOf(e.skillLevel),
                    e.raterEmployeeId,
                    joinPipe(e.sectionIds),
                    encodeDutyAssign(e.dutyAssignments)
            });
        }
        writeCsv(EMPS_FILE, rows);
    }

    void saveShifts() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (ShiftDefinition s : shifts) {
            rows.add(new String[]{
                    s.shiftId,
                    s.shiftName,
                    s.startTime.format(Input.TIME_FMT),
                    s.endTime.format(Input.TIME_FMT)
            });
        }
        writeCsv(SHIFTS_FILE, rows);
    }

    void saveEvents() {
        ArrayList<String[]> rows = new ArrayList<>();
        DateTimeFormatter dt = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        for (CalendarEvent ev : events) {
            rows.add(new String[]{
                    ev.eventId,
                    ev.eventType.toString(),
                    ev.title,
                    ev.notes,
                    ev.startDateTime.format(dt),
                    ev.endDateTime.format(dt),
                    ev.employeeIdOrNull,
                    ev.shiftIdOrBlank
            });
        }
        writeCsv(EVENTS_FILE, rows);
    }

    void saveAvailability() {
        ArrayList<String[]> rows = new ArrayList<>();
        DateTimeFormatter d = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        for (AvailabilityRecord a : availability) {
            rows.add(new String[]{a.employeeId, a.drillDate.format(d), String.valueOf(a.available)});
        }
        writeCsv(AVAIL_FILE, rows);
    }

    // ============================================================
    // EVENT ID GENERATION
    // ============================================================

    void updateNextEventIdCounter() {
        int max = 0;
        for (CalendarEvent ev : events) {
            int n = extractEventNumber(ev.eventId);
            if (n > max) max = n;
        }
        nextEventNumber = max + 1;
    }

    int extractEventNumber(String eventId) {
        if (eventId == null) return 0;
        String digits = eventId.replaceAll("[^0-9]", "");
        if (digits.isEmpty()) return 0;
        try { return Integer.parseInt(digits); } catch (Exception ex) { return 0; }
    }

    String nextEventId() {
        String id = String.format("EV%05d", nextEventNumber);
        nextEventNumber++;
        return id;
    }

    // ============================================================
    // SCHEDULING HELPERS
    // ============================================================

    boolean timeRangesOverlap(LocalDateTime startA, LocalDateTime endA, LocalDateTime startB, LocalDateTime endB) {
        return startA.isBefore(endB) && endA.isAfter(startB);
    }

    ArrayList<CalendarEvent> getEventsOnDate(LocalDate date) {
        ArrayList<CalendarEvent> result = new ArrayList<>();
        for (CalendarEvent ev : events) {
            LocalDate startD = ev.startDateTime.toLocalDate();
            LocalDate endD = ev.endDateTime.toLocalDate();
            if (!date.isBefore(startD) && !date.isAfter(endD)) result.add(ev);
        }
        return result;
    }

    ArrayList<CalendarEvent> getEmployeeEventsOnDate(String employeeId, LocalDate date) {
        ArrayList<CalendarEvent> result = new ArrayList<>();
        for (CalendarEvent ev : getEventsOnDate(date)) {
            if (!ev.isGlobal() && ev.employeeIdOrNull.equalsIgnoreCase(employeeId)) result.add(ev);
        }
        return result;
    }

    ArrayList<CalendarEvent> getEventsOverlapping(LocalDateTime start, LocalDateTime end) {
        ArrayList<CalendarEvent> result = new ArrayList<>();
        for (CalendarEvent ev : events) {
            if (timeRangesOverlap(start, end, ev.startDateTime, ev.endDateTime)) result.add(ev);
        }
        return result;
    }

    boolean hasGlobalEventTypeOnDate(LocalDate date, EventType type) {
        for (CalendarEvent ev : getEventsOnDate(date)) {
            if (ev.isGlobal() && ev.eventType == type && ev.startDateTime.toLocalDate().equals(date)) return true;
        }
        return false;
    }

    boolean isEmployeeOnOrders(String employeeId, LocalDate date) {
        for (CalendarEvent ev : events) {
            if (!ev.isGlobal() && ev.employeeIdOrNull.equalsIgnoreCase(employeeId) && ev.eventType == EventType.ORDERS) {
                LocalDate start = ev.startDateTime.toLocalDate();
                LocalDate end = ev.endDateTime.toLocalDate();
                if (!date.isBefore(start) && !date.isAfter(end)) return true;
            }
        }
        return false;
    }

    boolean isDrillOrAltDrillDay(LocalDate date) {
        return hasGlobalEventTypeOnDate(date, EventType.DRILL_DAY) || hasGlobalEventTypeOnDate(date, EventType.ALT_DRILL_DAY);
    }

    boolean isTraditionalAvailableForDrill(String employeeId, LocalDate date) {
        AvailabilityRecord a = findAvailability(employeeId, date);
        if (a == null) return false;
        return a.available;
    }

    boolean isEmployeeEligibleForDate(String employeeId, LocalDate date) {
        Employee e = findEmployee(employeeId);
        if (e == null) return false;

        if (e.type == EmploymentType.FULL_TIME) return true;

        if (isEmployeeOnOrders(employeeId, date)) return true;

        if (isDrillOrAltDrillDay(date) && isTraditionalAvailableForDrill(employeeId, date)) return true;

        return false;
    }

    String computeEmployeeStatus(Employee e, LocalDate date) {
        if (e.type == EmploymentType.TRADITIONAL) {
            if (isEmployeeOnOrders(e.employeeId, date)) return "AVAILABLE (ON ORDERS)";
            if (isDrillOrAltDrillDay(date) && isTraditionalAvailableForDrill(e.employeeId, date)) return "AVAILABLE (DRILL)";
            return "NOT AVAILABLE (TRADITIONAL RULES)";
        }

        // Full time: if blocked by key events, show it.
        for (CalendarEvent ev : getEmployeeEventsOnDate(e.employeeId, date)) {
            if (ev.eventType == EventType.DEPLOYMENT || ev.eventType == EventType.TDY || ev.eventType == EventType.LEAVE) {
                return "NOT AVAILABLE (" + ev.eventType + ")";
            }
        }

        return "AVAILABLE";
    }

    boolean requiresEligibilityCheck(EventType type) {
        // You should be able to add ORDERS/LEAVE/TDY even if the member isn't "eligible" yet.
        return type == EventType.SHIFT ||
               type == EventType.APPOINTMENT ||
               type == EventType.TRAINING ||
               type == EventType.NIGHT_FLYING;
    }

    // ============================================================
    // EVENT VALIDATION
    // ============================================================

    String validateEvent(String employeeIdOrBlank, EventType type, LocalDateTime startDT, LocalDateTime endDT, String ignoreEventId) {
        if (endDT.isBefore(startDT) || endDT.equals(startDT)) return "End must be after start.";

        // Global event validation is minimal.
        if (employeeIdOrBlank == null || employeeIdOrBlank.trim().isEmpty()) return null;

        Employee e = findEmployee(employeeIdOrBlank);
        if (e == null) return "Employee not found.";

        // Eligibility rules for traditionals only apply to "work schedule" items.
        if (e.type == EmploymentType.TRADITIONAL && requiresEligibilityCheck(type)) {
            LocalDate eventDate = startDT.toLocalDate();
            if (!isEmployeeEligibleForDate(employeeIdOrBlank, eventDate)) {
                return "Employee not eligible on " + eventDate + " (traditional must be on orders or available on drill day).";
            }
        }

        // Conflict rules: no overlap with any existing employee event.
        for (CalendarEvent existing : events) {
            if (existing.isGlobal()) continue;
            if (!existing.employeeIdOrNull.equalsIgnoreCase(employeeIdOrBlank)) continue;
            if (ignoreEventId != null && existing.eventId.equalsIgnoreCase(ignoreEventId)) continue;

            if (timeRangesOverlap(startDT, endDT, existing.startDateTime, existing.endDateTime)) {
                return "Conflict with " + existing.eventType + " (" + existing.startDateTime + " to " + existing.endDateTime + ") | " + existing.title;
            }
        }

        return null;
    }

    // ============================================================
    // FEDERAL HOLIDAYS
    // ============================================================

    void ensureFederalHolidaysForYear(int year) {
        boolean already = false;
        for (CalendarEvent ev : events) {
            if (ev.eventType == EventType.FEDERAL_HOLIDAY && ev.startDateTime.getYear() == year) { already = true; break; }
        }
        if (already) return;

        ArrayList<Holiday> holidays = FederalHolidayGenerator.generateHolidays(year);
        for (Holiday h : holidays) {
            CalendarEvent ev = new CalendarEvent();
            ev.eventId = nextEventId();
            ev.eventType = EventType.FEDERAL_HOLIDAY;
            ev.title = h.name;
            ev.notes = "Federal Holiday";
            ev.startDateTime = h.date.atStartOfDay();
            ev.endDateTime = h.date.atTime(23, 59);
            ev.employeeIdOrNull = "";
            ev.shiftIdOrBlank = "";
            events.add(ev);
        }
    }
}

/* ============================================================
 * FEDERAL HOLIDAY GENERATOR
 * ============================================================ */
class Holiday {
    String name;
    LocalDate date;
    Holiday(String name, LocalDate date) { this.name = name; this.date = date; }
}

class FederalHolidayGenerator {

    static ArrayList<Holiday> generateHolidays(int year) {
        ArrayList<Holiday> list = new ArrayList<>();

        list.add(new Holiday("New Year's Day", observedDate(LocalDate.of(year, 1, 1))));
        list.add(new Holiday("Juneteenth National Independence Day", observedDate(LocalDate.of(year, 6, 19))));
        list.add(new Holiday("Independence Day", observedDate(LocalDate.of(year, 7, 4))));
        list.add(new Holiday("Veterans Day", observedDate(LocalDate.of(year, 11, 11))));
        list.add(new Holiday("Christmas Day", observedDate(LocalDate.of(year, 12, 25))));

        list.add(new Holiday("Martin Luther King Jr. Day", nthWeekdayOfMonth(year, Month.JANUARY, DayOfWeek.MONDAY, 3)));
        list.add(new Holiday("Washington's Birthday", nthWeekdayOfMonth(year, Month.FEBRUARY, DayOfWeek.MONDAY, 3)));
        list.add(new Holiday("Labor Day", nthWeekdayOfMonth(year, Month.SEPTEMBER, DayOfWeek.MONDAY, 1)));
        list.add(new Holiday("Columbus Day", nthWeekdayOfMonth(year, Month.OCTOBER, DayOfWeek.MONDAY, 2)));
        list.add(new Holiday("Thanksgiving Day", nthWeekdayOfMonth(year, Month.NOVEMBER, DayOfWeek.THURSDAY, 4)));
        list.add(new Holiday("Memorial Day", lastWeekdayOfMonth(year, Month.MAY, DayOfWeek.MONDAY)));

        list.sort(Comparator.comparing(a -> a.date));
        return list;
    }

    static LocalDate observedDate(LocalDate actual) {
        DayOfWeek dow = actual.getDayOfWeek();
        if (dow == DayOfWeek.SATURDAY) return actual.minusDays(1);
        if (dow == DayOfWeek.SUNDAY) return actual.plusDays(1);
        return actual;
    }

    static LocalDate nthWeekdayOfMonth(int year, Month month, DayOfWeek weekday, int n) {
        LocalDate first = LocalDate.of(year, month, 1);
        return first.with(TemporalAdjusters.dayOfWeekInMonth(n, weekday));
    }

    static LocalDate lastWeekdayOfMonth(int year, Month month, DayOfWeek weekday) {
        LocalDate last = LocalDate.of(year, month, month.length(Year.isLeap(year)));
        return last.with(TemporalAdjusters.previousOrSame(weekday));
    }
}
