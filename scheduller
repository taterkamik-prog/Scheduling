import java.io.*;
import java.util.*;

/* ============================================================
 * PROGRAM ENTRY POINT
 * ============================================================
 * Purpose:
 * - Starts the program
 * - Loads CSV data into memory
 * - Displays the main menu loop
 * - Routes to sub-menus
 * - Saves CSV data when requested
 */
public class Main {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        Store store = new Store();
        store.loadAll();

        while (true) {
            System.out.println("\n=== MAIN MENU ===");
            System.out.println("1) Organization");
            System.out.println("2) Employees");
            System.out.println("3) Additional Duties (by Section)");
            System.out.println("4) Reports");
            System.out.println("5) Save");
            System.out.println("6) Save & Exit");

            int choice = Input.readIntInRange(sc, "Choice: ", 1, 6);

            if (choice == 1) {
                Menus.organization(sc, store);
            } else if (choice == 2) {
                Menus.employees(sc, store);
            } else if (choice == 3) {
                Menus.duties(sc, store);
            } else if (choice == 4) {
                Menus.reports(sc, store);
            } else if (choice == 5) {
                store.saveAll();
                System.out.println("Saved.");
            } else if (choice == 6) {
                store.saveAll();
                System.out.println("Saved. Exiting.");
                break;
            }
        }

        sc.close();
    }
}

/* ============================================================
 * INPUT HELPERS
 * ============================================================
 * Purpose:
 * - Prevents crashes caused by bad user input
 * - Keeps menus from breaking due to NumberFormatException
 * - Supports a "back out" option on many prompts
 */
class Input {

    // Notes:
    // - Reads an integer within a range.
    // - Keeps asking until a valid integer is entered.
    static int readIntInRange(Scanner sc, String prompt, int min, int max) {
        while (true) {
            System.out.print(prompt);
            String s = sc.nextLine().trim();

            try {
                int val = Integer.parseInt(s);
                if (val < min || val > max) {
                    System.out.println("ERROR: Enter a number from " + min + " to " + max + ".");
                    continue;
                }
                return val;
            } catch (Exception ex) {
                System.out.println("ERROR: Enter a whole number.");
            }
        }
    }

    // Notes:
    // - Reads an integer within a range OR returns null if the user enters "b".
    // - Useful for backing out of a multi-step flow.
    static Integer readIntInRangeAllowBack(Scanner sc, String prompt, int min, int max) {
        while (true) {
            System.out.print(prompt);
            String s = sc.nextLine().trim();

            if (s.equalsIgnoreCase("b")) {
                return null;
            }

            try {
                int val = Integer.parseInt(s);
                if (val < min || val > max) {
                    System.out.println("ERROR: Enter a number from " + min + " to " + max + " (or b to go back).");
                    continue;
                }
                return val;
            } catch (Exception ex) {
                System.out.println("ERROR: Enter a whole number (or b to go back).");
            }
        }
    }

    // Notes:
    // - Reads a string and returns it exactly as typed (trimmed).
    static String readString(Scanner sc, String prompt) {
        System.out.print(prompt);
        return sc.nextLine().trim();
    }

    // Notes:
    // - Reads a string OR returns null if the user enters "b".
    static String readStringAllowBack(Scanner sc, String prompt) {
        System.out.print(prompt);
        String s = sc.nextLine().trim();
        if (s.equalsIgnoreCase("b")) return null;
        return s;
    }
}

/* ============================================================
 * MENU CONTROLLER
 * ============================================================
 * Purpose:
 * - Contains menu loops for each major feature:
 *   - Organization structure
 *   - Employee management
 *   - Section duty lists
 *   - Reporting (duties + rater/ratee)
 *
 * Notes:
 * - Each menu is a loop that stays in that menu until "Back" is chosen.
 */
class Menus {

    /* ============================================================
     * ORGANIZATION MENU
     * ============================================================
     * Purpose:
     * - Create/edit/delete the organization structure:
     *   Wing -> Group -> Squadron -> Section
     * - Assign parent-child relationships between levels
     */
    static void organization(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- ORGANIZATION ---");
            System.out.println("1) Create Wing");
            System.out.println("2) Create Group");
            System.out.println("3) Create Squadron");
            System.out.println("4) Create Section");
            System.out.println("5) Edit Wing Name");
            System.out.println("6) Edit Group Name");
            System.out.println("7) Edit Squadron Name");
            System.out.println("8) Edit Section Name");
            System.out.println("9) Delete Wing");
            System.out.println("10) Delete Group");
            System.out.println("11) Delete Squadron");
            System.out.println("12) Delete Section");
            System.out.println("13) Assign Group -> Wing");
            System.out.println("14) Assign Squadron -> Group");
            System.out.println("15) Assign Section -> Squadron");
            System.out.println("16) List All");
            System.out.println("17) Back");

            int c = Input.readIntInRange(sc, "Choice: ", 1, 17);

            if (c == 1) createWing(sc, st);
            else if (c == 2) createGroup(sc, st);
            else if (c == 3) createSquadron(sc, st);
            else if (c == 4) createSection(sc, st);
            else if (c == 5) editWing(sc, st);
            else if (c == 6) editGroup(sc, st);
            else if (c == 7) editSquadron(sc, st);
            else if (c == 8) editSection(sc, st);
            else if (c == 9) deleteWing(sc, st);
            else if (c == 10) deleteGroup(sc, st);
            else if (c == 11) deleteSquadron(sc, st);
            else if (c == 12) deleteSection(sc, st);
            else if (c == 13) assignGroupToWing(sc, st);
            else if (c == 14) assignSquadronToGroup(sc, st);
            else if (c == 15) assignSectionToSquadron(sc, st);
            else if (c == 16) listOrg(st);
            else if (c == 17) return;
        }
    }

    /* ============================================================
     * EMPLOYEE MENU
     * ============================================================
     * Purpose:
     * - Create/edit/delete employees
     * - View employee details
     * - Assign employees to multiple sections
     * - Assign/remove section-specific additional duties
     * - Assign/clear rater (another employee)
     */
    static void employees(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- EMPLOYEES ---");
            System.out.println("1) Add Employee");
            System.out.println("2) Edit Employee");
            System.out.println("3) Delete Employee");
            System.out.println("4) List Employees");
            System.out.println("5) View Employee Details");
            System.out.println("6) Assign Employee to Section");
            System.out.println("7) Remove Employee from Section");
            System.out.println("8) Assign Additional Duty (Employee)");
            System.out.println("9) Remove Additional Duty (Employee)");
            System.out.println("10) Set/Clear Assigned Rater");
            System.out.println("11) Back");

            int c = Input.readIntInRange(sc, "Choice: ", 1, 11);

            if (c == 1) addEmployee(sc, st);
            else if (c == 2) editEmployee(sc, st);
            else if (c == 3) deleteEmployee(sc, st);
            else if (c == 4) listEmployees(st);
            else if (c == 5) viewEmployeeDetails(sc, st);
            else if (c == 6) assignEmpToSection(sc, st);
            else if (c == 7) removeEmpFromSection(sc, st);
            else if (c == 8) assignDutyToEmployee(sc, st);
            else if (c == 9) removeDutyFromEmployee(sc, st);
            else if (c == 10) setRater(sc, st);
            else if (c == 11) return;
        }
    }

    /* ============================================================
     * ADDITIONAL DUTIES MENU
     * ============================================================
     * Purpose:
     * - Duties are defined at the Section level (allowed duty names).
     * - This menu edits the duty catalog for a specific Section.
     * - Employees can only be assigned duties that exist in their Section.
     */
    static void duties(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- ADDITIONAL DUTIES (BY SECTION) ---");
            System.out.println("1) View Duties for Section");
            System.out.println("2) Add Duty to Section");
            System.out.println("3) Rename Duty in Section");
            System.out.println("4) Delete Duty from Section");
            System.out.println("5) Back");

            int c = Input.readIntInRange(sc, "Choice: ", 1, 5);

            if (c == 1) viewSectionDuties(sc, st);
            else if (c == 2) addDutyToSection(sc, st);
            else if (c == 3) renameDutyInSection(sc, st);
            else if (c == 4) deleteDutyFromSection(sc, st);
            else if (c == 5) return;
        }
    }

    /* ============================================================
     * REPORTS MENU
     * ============================================================
     * Purpose:
     * - Duty reporting both directions:
     *   - Duties assigned to each employee
     *   - Employees assigned to a specific duty
     * - Rater/ratee reporting:
     *   - Ratees for a given rater
     *   - Employees missing a rater
     * - Duty counts:
     *   - How many employees hold each duty in a section
     */
    static void reports(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- REPORTS ---");
            System.out.println("1) Report: Duties by Employee");
            System.out.println("2) Report: Employees by Duty (Section)");
            System.out.println("3) Report: Duty Counts (Section)");
            System.out.println("4) Report: Ratees for Rater");
            System.out.println("5) Report: Employees Missing Rater");
            System.out.println("6) Back");

            int c = Input.readIntInRange(sc, "Choice: ", 1, 6);

            if (c == 1) reportDutiesByEmployee(st);
            else if (c == 2) reportEmployeesByDuty(sc, st);
            else if (c == 3) reportDutyCountsForSection(sc, st);
            else if (c == 4) reportRateesForRater(sc, st);
            else if (c == 5) reportEmployeesMissingRater(st);
            else if (c == 6) return;
        }
    }

    // ============================================================
    // ORGANIZATION: CREATE
    // ============================================================

    static void createWing(Scanner sc, Store st) {
        System.out.println("\nCreate Wing (enter b to go back)");
        String id = Input.readStringAllowBack(sc, "Wing ID: ");
        if (id == null) return;

        if (st.findWing(id) != null) { System.out.println("ERROR: Wing ID exists."); return; }

        String name = Input.readString(sc, "Wing Name: ");
        st.wings.add(new Wing(id, name));
        System.out.println("SUCCESS.");
    }

    static void createGroup(Scanner sc, Store st) {
        System.out.println("\nCreate Group (enter b to go back)");
        String id = Input.readStringAllowBack(sc, "Group ID: ");
        if (id == null) return;

        if (st.findGroup(id) != null) { System.out.println("ERROR: Group ID exists."); return; }

        String name = Input.readString(sc, "Group Name: ");
        st.groups.add(new Group(id, name));
        System.out.println("SUCCESS.");
    }

    static void createSquadron(Scanner sc, Store st) {
        System.out.println("\nCreate Squadron (enter b to go back)");
        String id = Input.readStringAllowBack(sc, "Squadron ID: ");
        if (id == null) return;

        if (st.findSquadron(id) != null) { System.out.println("ERROR: Squadron ID exists."); return; }

        String name = Input.readString(sc, "Squadron Name: ");
        st.squadrons.add(new Squadron(id, name));
        System.out.println("SUCCESS.");
    }

    static void createSection(Scanner sc, Store st) {
        System.out.println("\nCreate Section (enter b to go back)");
        String id = Input.readStringAllowBack(sc, "Section ID: ");
        if (id == null) return;

        if (st.findSection(id) != null) { System.out.println("ERROR: Section ID exists."); return; }

        String name = Input.readString(sc, "Section Name: ");
        st.sections.add(new Section(id, name));
        System.out.println("SUCCESS.");
    }

    // ============================================================
    // ORGANIZATION: EDIT
    // ============================================================

    static void editWing(Scanner sc, Store st) {
        System.out.println("\nEdit Wing (enter b to go back)");
        listWings(st);
        String id = Input.readStringAllowBack(sc, "Wing ID: ");
        if (id == null) return;

        Wing w = st.findWing(id);
        if (w == null) { System.out.println("ERROR: Wing not found."); return; }

        w.name = Input.readString(sc, "New Name: ");
        System.out.println("SUCCESS.");
    }

    static void editGroup(Scanner sc, Store st) {
        System.out.println("\nEdit Group (enter b to go back)");
        listGroups(st);
        String id = Input.readStringAllowBack(sc, "Group ID: ");
        if (id == null) return;

        Group g = st.findGroup(id);
        if (g == null) { System.out.println("ERROR: Group not found."); return; }

        g.name = Input.readString(sc, "New Name: ");
        System.out.println("SUCCESS.");
    }

    static void editSquadron(Scanner sc, Store st) {
        System.out.println("\nEdit Squadron (enter b to go back)");
        listSquadrons(st);
        String id = Input.readStringAllowBack(sc, "Squadron ID: ");
        if (id == null) return;

        Squadron s = st.findSquadron(id);
        if (s == null) { System.out.println("ERROR: Squadron not found."); return; }

        s.name = Input.readString(sc, "New Name: ");
        System.out.println("SUCCESS.");
    }

    static void editSection(Scanner sc, Store st) {
        System.out.println("\nEdit Section (enter b to go back)");
        listSections(st);
        String id = Input.readStringAllowBack(sc, "Section ID: ");
        if (id == null) return;

        Section s = st.findSection(id);
        if (s == null) { System.out.println("ERROR: Section not found."); return; }

        s.name = Input.readString(sc, "New Name: ");
        System.out.println("SUCCESS.");
    }

    // ============================================================
    // ORGANIZATION: DELETE
    // ============================================================

    static void deleteWing(Scanner sc, Store st) {
        System.out.println("\nDelete Wing (enter b to go back)");
        listWings(st);
        String id = Input.readStringAllowBack(sc, "Wing ID: ");
        if (id == null) return;

        Wing w = st.findWing(id);
        if (w == null) { System.out.println("ERROR: Wing not found."); return; }

        // Notes:
        // - If a wing is deleted, groups that point to it become unassigned.
        for (Group g : st.groups) if (g.wingId.equalsIgnoreCase(id)) g.wingId = "";
        st.wings.remove(w);

        System.out.println("SUCCESS: Deleted. Groups unassigned.");
    }

    static void deleteGroup(Scanner sc, Store st) {
        System.out.println("\nDelete Group (enter b to go back)");
        listGroups(st);
        String id = Input.readStringAllowBack(sc, "Group ID: ");
        if (id == null) return;

        Group g = st.findGroup(id);
        if (g == null) { System.out.println("ERROR: Group not found."); return; }

        // Notes:
        // - If a group is deleted, squadrons that point to it become unassigned.
        for (Squadron sq : st.squadrons) if (sq.groupId.equalsIgnoreCase(id)) sq.groupId = "";
        st.groups.remove(g);

        System.out.println("SUCCESS: Deleted. Squadrons unassigned.");
    }

    static void deleteSquadron(Scanner sc, Store st) {
        System.out.println("\nDelete Squadron (enter b to go back)");
        listSquadrons(st);
        String id = Input.readStringAllowBack(sc, "Squadron ID: ");
        if (id == null) return;

        Squadron s = st.findSquadron(id);
        if (s == null) { System.out.println("ERROR: Squadron not found."); return; }

        // Notes:
        // - If a squadron is deleted, sections that point to it become unassigned.
        for (Section sec : st.sections) if (sec.squadronId.equalsIgnoreCase(id)) sec.squadronId = "";
        st.squadrons.remove(s);

        System.out.println("SUCCESS: Deleted. Sections unassigned.");
    }

    static void deleteSection(Scanner sc, Store st) {
        System.out.println("\nDelete Section (enter b to go back)");
        listSections(st);
        String id = Input.readStringAllowBack(sc, "Section ID: ");
        if (id == null) return;

        Section sec = st.findSection(id);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }

        // Notes:
        // - If a section is deleted, employees must lose:
        //   - membership in that section
        //   - duty assignments tied to that section
        for (Employee e : st.employees) {
            e.sectionIds.removeIf(sid -> sid.equalsIgnoreCase(id));
            e.dutyAssignments.removeIf(a -> a.sectionId.equalsIgnoreCase(id));
        }

        st.sections.remove(sec);
        System.out.println("SUCCESS: Deleted. Employee memberships/duties removed.");
    }

    // ============================================================
    // ORGANIZATION: ASSIGN RELATIONSHIPS
    // ============================================================

    static void assignGroupToWing(Scanner sc, Store st) {
        System.out.println("\nAssign Group -> Wing (enter b to go back)");
        listGroups(st);
        String gid = Input.readStringAllowBack(sc, "Group ID: ");
        if (gid == null) return;

        Group g = st.findGroup(gid);
        if (g == null) { System.out.println("ERROR: Group not found."); return; }

        listWings(st);
        System.out.println("Notes: Enter blank to unassign. Enter b to cancel.");
        String wid = Input.readStringAllowBack(sc, "Wing ID (blank to unassign): ");
        if (wid == null) return;

        if (wid.isEmpty()) { g.wingId = ""; System.out.println("SUCCESS: Unassigned."); return; }

        Wing w = st.findWing(wid);
        if (w == null) { System.out.println("ERROR: Wing not found."); return; }

        g.wingId = w.wingId;
        System.out.println("SUCCESS.");
    }

    static void assignSquadronToGroup(Scanner sc, Store st) {
        System.out.println("\nAssign Squadron -> Group (enter b to go back)");
        listSquadrons(st);
        String sid = Input.readStringAllowBack(sc, "Squadron ID: ");
        if (sid == null) return;

        Squadron sq = st.findSquadron(sid);
        if (sq == null) { System.out.println("ERROR: Squadron not found."); return; }

        listGroups(st);
        System.out.println("Notes: Enter blank to unassign. Enter b to cancel.");
        String gid = Input.readStringAllowBack(sc, "Group ID (blank to unassign): ");
        if (gid == null) return;

        if (gid.isEmpty()) { sq.groupId = ""; System.out.println("SUCCESS: Unassigned."); return; }

        Group g = st.findGroup(gid);
        if (g == null) { System.out.println("ERROR: Group not found."); return; }

        sq.groupId = g.groupId;
        System.out.println("SUCCESS.");
    }

    static void assignSectionToSquadron(Scanner sc, Store st) {
        System.out.println("\nAssign Section -> Squadron (enter b to go back)");
        listSections(st);
        String secId = Input.readStringAllowBack(sc, "Section ID: ");
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }

        listSquadrons(st);
        System.out.println("Notes: Enter blank to unassign. Enter b to cancel.");
        String sqId = Input.readStringAllowBack(sc, "Squadron ID (blank to unassign): ");
        if (sqId == null) return;

        if (sqId.isEmpty()) { sec.squadronId = ""; System.out.println("SUCCESS: Unassigned."); return; }

        Squadron sq = st.findSquadron(sqId);
        if (sq == null) { System.out.println("ERROR: Squadron not found."); return; }

        sec.squadronId = sq.squadronId;
        System.out.println("SUCCESS.");
    }

    // ============================================================
    // ORGANIZATION: LIST HELPERS
    // ============================================================

    static void listOrg(Store st) {
        System.out.println("\nWINGS"); listWings(st);
        System.out.println("\nGROUPS"); listGroups(st);
        System.out.println("\nSQUADRONS"); listSquadrons(st);
        System.out.println("\nSECTIONS"); listSections(st);
    }

    static void listWings(Store st) {
        if (st.wings.isEmpty()) { System.out.println("(None)"); return; }
        for (Wing w : st.wings) System.out.println(w.wingId + " | " + w.name);
    }

    static void listGroups(Store st) {
        if (st.groups.isEmpty()) { System.out.println("(None)"); return; }
        for (Group g : st.groups) {
            System.out.println(g.groupId + " | " + g.name + " | Wing: " + (g.wingId.isEmpty() ? "UNASSIGNED" : g.wingId));
        }
    }

    static void listSquadrons(Store st) {
        if (st.squadrons.isEmpty()) { System.out.println("(None)"); return; }
        for (Squadron s : st.squadrons) {
            System.out.println(s.squadronId + " | " + s.name + " | Group: " + (s.groupId.isEmpty() ? "UNASSIGNED" : s.groupId));
        }
    }

    static void listSections(Store st) {
        if (st.sections.isEmpty()) { System.out.println("(None)"); return; }
        for (Section s : st.sections) {
            System.out.println(s.sectionId + " | " + s.name + " | Squadron: " + (s.squadronId.isEmpty() ? "UNASSIGNED" : s.squadronId));
        }
    }

    // ============================================================
    // EMPLOYEES: CREATE/EDIT/DELETE/LIST
    // ============================================================

    static void addEmployee(Scanner sc, Store st) {
        System.out.println("\nAdd Employee (enter b to go back)");
        String id = Input.readStringAllowBack(sc, "Employee ID: ");
        if (id == null) return;

        if (st.findEmployee(id) != null) { System.out.println("ERROR: Employee ID exists."); return; }

        Employee e = new Employee(id);

        e.rank = Input.readString(sc, "Rank: ");
        e.firstName = Input.readString(sc, "First Name: ");
        e.lastName = Input.readString(sc, "Last Name: ");

        while (true) {
            String t = Input.readString(sc, "Employment Type (FULL_TIME/TRADITIONAL): ").toUpperCase();
            try {
                e.type = EmploymentType.valueOf(t);
                break;
            } catch (Exception ex) {
                System.out.println("ERROR: Type must be FULL_TIME or TRADITIONAL.");
            }
        }

        while (true) {
            String s = Input.readString(sc, "Skill Level (number): ");
            try {
                e.skillLevel = Integer.parseInt(s);
                break;
            } catch (Exception ex) {
                System.out.println("ERROR: Enter a whole number.");
            }
        }

        st.employees.add(e);
        System.out.println("SUCCESS.");
    }

    static void editEmployee(Scanner sc, Store st) {
        System.out.println("\nEdit Employee (enter b to go back)");
        listEmployees(st);

        String id = Input.readStringAllowBack(sc, "Employee ID: ");
        if (id == null) return;

        Employee e = st.findEmployee(id);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        System.out.println("1) Rank");
        System.out.println("2) First Name");
        System.out.println("3) Last Name");
        System.out.println("4) Employment Type");
        System.out.println("5) Skill Level");
        Integer f = Input.readIntInRangeAllowBack(sc, "Field (or b): ", 1, 5);
        if (f == null) return;

        if (f == 1) {
            e.rank = Input.readString(sc, "New Rank: ");
        } else if (f == 2) {
            e.firstName = Input.readString(sc, "New First Name: ");
        } else if (f == 3) {
            e.lastName = Input.readString(sc, "New Last Name: ");
        } else if (f == 4) {
            while (true) {
                String t = Input.readString(sc, "Employment Type (FULL_TIME/TRADITIONAL): ").toUpperCase();
                try {
                    e.type = EmploymentType.valueOf(t);
                    break;
                } catch (Exception ex) {
                    System.out.println("ERROR: Type must be FULL_TIME or TRADITIONAL.");
                }
            }
        } else if (f == 5) {
            while (true) {
                String s = Input.readString(sc, "New Skill Level (number): ");
                try {
                    e.skillLevel = Integer.parseInt(s);
                    break;
                } catch (Exception ex) {
                    System.out.println("ERROR: Enter a whole number.");
                }
            }
        }

        System.out.println("SUCCESS.");
    }

    static void deleteEmployee(Scanner sc, Store st) {
        System.out.println("\nDelete Employee (enter b to go back)");
        listEmployees(st);

        String id = Input.readStringAllowBack(sc, "Employee ID: ");
        if (id == null) return;

        Employee e = st.findEmployee(id);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        // Notes:
        // - If an employee is deleted, any other employee that had them as rater must be cleared.
        for (Employee other : st.employees) {
            if (other.raterEmployeeId.equalsIgnoreCase(id)) other.raterEmployeeId = "";
        }

        st.employees.remove(e);
        System.out.println("SUCCESS.");
    }

    static void listEmployees(Store st) {
        System.out.println("\nEMPLOYEES");
        if (st.employees.isEmpty()) { System.out.println("(None)"); return; }
        for (Employee e : st.employees) {
            System.out.println(e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName + " | " + e.type + " | Skill " + e.skillLevel);
        }
    }

    // ============================================================
    // EMPLOYEES: VIEW DETAILS
    // ============================================================

    static void viewEmployeeDetails(Scanner sc, Store st) {
        System.out.println("\nView Employee Details (enter b to go back)");
        listEmployees(st);

        String id = Input.readStringAllowBack(sc, "Employee ID: ");
        if (id == null) return;

        Employee e = st.findEmployee(id);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        System.out.println("\nDETAILS: " + e.employeeId);
        System.out.println("Name: " + e.rank + " " + e.firstName + " " + e.lastName);
        System.out.println("Type: " + e.type);
        System.out.println("Skill: " + e.skillLevel);

        if (e.raterEmployeeId.isEmpty()) {
            System.out.println("Rater: (None)");
        } else {
            Employee r = st.findEmployee(e.raterEmployeeId);
            System.out.println("Rater: " + e.raterEmployeeId + (r == null ? " (missing record)" : " (" + r.rank + " " + r.lastName + ")"));
        }

        System.out.println("\nSections:");
        if (e.sectionIds.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (String sid : e.sectionIds) {
                System.out.println(" - " + st.formatSectionChain(sid));
            }
        }

        System.out.println("\nAdditional Duties:");
        if (e.dutyAssignments.isEmpty()) {
            System.out.println("(None)");
        } else {
            for (DutyAssign a : e.dutyAssignments) {
                System.out.println(" - " + st.formatSectionChain(a.sectionId) + " => " + a.dutyName);
            }
        }
    }

    // ============================================================
    // EMPLOYEES: SECTION MEMBERSHIP
    // ============================================================

    static void assignEmpToSection(Scanner sc, Store st) {
        System.out.println("\nAssign Employee to Section (enter b to go back)");
        listEmployees(st);

        String empId = Input.readStringAllowBack(sc, "Employee ID: ");
        if (empId == null) return;

        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        listSections(st);

        String secId = Input.readStringAllowBack(sc, "Section ID: ");
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }

        if (st.containsIgnoreCase(e.sectionIds, sec.sectionId)) { System.out.println("ERROR: Already assigned."); return; }

        e.sectionIds.add(sec.sectionId);
        System.out.println("SUCCESS.");
    }

    static void removeEmpFromSection(Scanner sc, Store st) {
        System.out.println("\nRemove Employee from Section (enter b to go back)");
        listEmployees(st);

        String empId = Input.readStringAllowBack(sc, "Employee ID: ");
        if (empId == null) return;

        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        if (e.sectionIds.isEmpty()) { System.out.println("ERROR: Employee has no sections."); return; }

        System.out.println("Sections:");
        for (String sid : e.sectionIds) System.out.println(" - " + st.formatSectionChain(sid));

        String secId = Input.readStringAllowBack(sc, "Section ID to remove: ");
        if (secId == null) return;

        boolean removed = e.sectionIds.removeIf(sid -> sid.equalsIgnoreCase(secId));

        // Notes:
        // - If the employee leaves a section, remove any duties tied to that section.
        e.dutyAssignments.removeIf(a -> a.sectionId.equalsIgnoreCase(secId));

        if (!removed) { System.out.println("ERROR: Not a member of that section."); return; }
        System.out.println("SUCCESS.");
    }

    // ============================================================
    // EMPLOYEES: DUTY ASSIGNMENTS
    // ============================================================

    static void assignDutyToEmployee(Scanner sc, Store st) {
        System.out.println("\nAssign Additional Duty to Employee (enter b to go back)");
        listEmployees(st);

        String empId = Input.readStringAllowBack(sc, "Employee ID: ");
        if (empId == null) return;

        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        if (e.sectionIds.isEmpty()) { System.out.println("ERROR: Employee has no section memberships."); return; }

        System.out.println("Employee Sections:");
        for (String sid : e.sectionIds) System.out.println(" - " + st.formatSectionChain(sid));

        String secId = Input.readStringAllowBack(sc, "Section ID: ");
        if (secId == null) return;

        if (!st.containsIgnoreCase(e.sectionIds, secId)) { System.out.println("ERROR: Employee not in that section."); return; }

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }

        if (sec.dutyNames.isEmpty()) { System.out.println("ERROR: Section has no duties. Add in Duties menu."); return; }

        System.out.println("Section Duties:");
        for (int i = 0; i < sec.dutyNames.size(); i++) {
            String d = sec.dutyNames.get(i);
            int count = st.countEmployeesAssignedToDuty(sec.sectionId, d);
            System.out.println((i + 1) + ") " + d + " (assigned: " + count + ")");
        }

        Integer idx = Input.readIntInRangeAllowBack(sc, "Duty choice # (or b): ", 1, sec.dutyNames.size());
        if (idx == null) return;

        String dutyName = sec.dutyNames.get(idx - 1);

        if (st.employeeHasDuty(e, sec.sectionId, dutyName)) { System.out.println("ERROR: Already assigned."); return; }

        e.dutyAssignments.add(new DutyAssign(sec.sectionId, dutyName));
        System.out.println("SUCCESS.");
    }

    static void removeDutyFromEmployee(Scanner sc, Store st) {
        System.out.println("\nRemove Additional Duty from Employee (enter b to go back)");
        listEmployees(st);

        String empId = Input.readStringAllowBack(sc, "Employee ID: ");
        if (empId == null) return;

        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        if (e.dutyAssignments.isEmpty()) { System.out.println("ERROR: No duty assignments."); return; }

        System.out.println("Current Assignments:");
        for (int i = 0; i < e.dutyAssignments.size(); i++) {
            DutyAssign a = e.dutyAssignments.get(i);
            System.out.println((i + 1) + ") " + st.formatSectionChain(a.sectionId) + " => " + a.dutyName);
        }

        Integer idx = Input.readIntInRangeAllowBack(sc, "Assignment # to remove (or b): ", 1, e.dutyAssignments.size());
        if (idx == null) return;

        e.dutyAssignments.remove((int) (idx - 1));
        System.out.println("SUCCESS.");
    }

    // ============================================================
    // EMPLOYEES: RATER ASSIGNMENT
    // ============================================================

    static void setRater(Scanner sc, Store st) {
        System.out.println("\nSet/Clear Rater (enter b to go back)");
        listEmployees(st);

        String empId = Input.readStringAllowBack(sc, "Employee ID to update: ");
        if (empId == null) return;

        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        System.out.println("Current rater: " + (e.raterEmployeeId.isEmpty() ? "(None)" : e.raterEmployeeId));
        System.out.println("Notes: Enter blank to clear. Enter b to cancel.");

        String raterId = Input.readStringAllowBack(sc, "Rater Employee ID (blank to clear): ");
        if (raterId == null) return;

        if (raterId.isEmpty()) { e.raterEmployeeId = ""; System.out.println("SUCCESS."); return; }
        if (raterId.equalsIgnoreCase(empId)) { System.out.println("ERROR: Cannot be own rater."); return; }
        if (st.findEmployee(raterId) == null) { System.out.println("ERROR: Rater not found."); return; }

        e.raterEmployeeId = raterId;
        System.out.println("SUCCESS.");
    }

    // ============================================================
    // DUTIES MENU: SECTION DUTY LIST MANAGEMENT
    // ============================================================

    static void viewSectionDuties(Scanner sc, Store st) {
        System.out.println("\nView Duties for Section (enter b to go back)");
        listSections(st);

        String secId = Input.readStringAllowBack(sc, "Section ID: ");
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }

        System.out.println("\nDuties for " + sec.sectionId + " (" + sec.name + ")");
        if (sec.dutyNames.isEmpty()) {
            System.out.println("(None)");
            return;
        }

        for (String d : sec.dutyNames) {
            int count = st.countEmployeesAssignedToDuty(sec.sectionId, d);
            System.out.println(" - " + d + " (assigned: " + count + ")");
        }
    }

    static void addDutyToSection(Scanner sc, Store st) {
        System.out.println("\nAdd Duty to Section (enter b to go back)");
        listSections(st);

        String secId = Input.readStringAllowBack(sc, "Section ID: ");
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }

        String duty = Input.readStringAllowBack(sc, "Duty Name: ");
        if (duty == null) return;

        if (duty.isEmpty()) { System.out.println("ERROR: Blank duty name."); return; }
        if (st.sectionHasDuty(secId, duty)) { System.out.println("ERROR: Duty exists."); return; }

        sec.dutyNames.add(duty);
        System.out.println("SUCCESS.");
    }

    static void renameDutyInSection(Scanner sc, Store st) {
        System.out.println("\nRename Duty in Section (enter b to go back)");
        listSections(st);

        String secId = Input.readStringAllowBack(sc, "Section ID: ");
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }
        if (sec.dutyNames.isEmpty()) { System.out.println("ERROR: No duties to rename."); return; }

        System.out.println("Duties:");
        for (String d : sec.dutyNames) System.out.println(" - " + d);

        String oldName = Input.readStringAllowBack(sc, "Old Duty Name (exact): ");
        if (oldName == null) return;

        if (!st.sectionHasDuty(secId, oldName)) { System.out.println("ERROR: Duty not found."); return; }

        String newName = Input.readStringAllowBack(sc, "New Duty Name: ");
        if (newName == null) return;

        if (newName.isEmpty()) { System.out.println("ERROR: Blank duty name."); return; }
        if (st.sectionHasDuty(secId, newName)) { System.out.println("ERROR: New duty name already exists."); return; }

        for (int i = 0; i < sec.dutyNames.size(); i++) {
            if (sec.dutyNames.get(i).equalsIgnoreCase(oldName)) { sec.dutyNames.set(i, newName); break; }
        }

        // Notes:
        // - Renaming a duty also updates employee assignments so they still point to the correct duty.
        for (Employee e : st.employees) {
            for (DutyAssign a : e.dutyAssignments) {
                if (a.sectionId.equalsIgnoreCase(secId) && a.dutyName.equalsIgnoreCase(oldName)) a.dutyName = newName;
            }
        }

        System.out.println("SUCCESS.");
    }

    static void deleteDutyFromSection(Scanner sc, Store st) {
        System.out.println("\nDelete Duty from Section (enter b to go back)");
        listSections(st);

        String secId = Input.readStringAllowBack(sc, "Section ID: ");
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }
        if (sec.dutyNames.isEmpty()) { System.out.println("ERROR: No duties to delete."); return; }

        System.out.println("Duties:");
        for (String d : sec.dutyNames) System.out.println(" - " + d);

        String duty = Input.readStringAllowBack(sc, "Duty Name to delete (exact): ");
        if (duty == null) return;

        if (!st.sectionHasDuty(secId, duty)) { System.out.println("ERROR: Duty not found."); return; }

        sec.dutyNames.removeIf(d -> d.equalsIgnoreCase(duty));

        // Notes:
        // - If a duty is deleted from a section, remove that duty from all employees.
        for (Employee e : st.employees) {
            e.dutyAssignments.removeIf(a -> a.sectionId.equalsIgnoreCase(secId) && a.dutyName.equalsIgnoreCase(duty));
        }

        System.out.println("SUCCESS.");
    }

    // ============================================================
    // REPORTS
    // ============================================================

    static void reportDutiesByEmployee(Store st) {
        System.out.println("\n=== DUTIES BY EMPLOYEE ===");
        if (st.employees.isEmpty()) { System.out.println("(No employees)"); return; }

        for (Employee e : st.employees) {
            System.out.println("\n" + e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName);

            if (e.dutyAssignments.isEmpty()) {
                System.out.println("  (No duty assignments)");
            } else {
                for (DutyAssign a : e.dutyAssignments) {
                    System.out.println("  - " + st.formatSectionChain(a.sectionId) + " => " + a.dutyName);
                }
            }
        }
    }

    static void reportEmployeesByDuty(Scanner sc, Store st) {
        System.out.println("\n=== EMPLOYEES BY DUTY (SECTION) ===");
        if (st.sections.isEmpty()) { System.out.println("(No sections)"); return; }

        listSections(st);
        String secId = Input.readStringAllowBack(sc, "Section ID (or b): ");
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }

        if (sec.dutyNames.isEmpty()) { System.out.println("ERROR: This section has no duties."); return; }

        System.out.println("\nDuties for " + sec.sectionId + " (" + sec.name + ")");
        for (int i = 0; i < sec.dutyNames.size(); i++) {
            String d = sec.dutyNames.get(i);
            int count = st.countEmployeesAssignedToDuty(sec.sectionId, d);
            System.out.println((i + 1) + ") " + d + " (assigned: " + count + ")");
        }

        Integer idx = Input.readIntInRangeAllowBack(sc, "Duty choice # (or b): ", 1, sec.dutyNames.size());
        if (idx == null) return;

        String dutyName = sec.dutyNames.get(idx - 1);

        ArrayList<Employee> assigned = st.findEmployeesAssignedToDuty(sec.sectionId, dutyName);

        System.out.println("\nSection: " + st.formatSectionChain(sec.sectionId));
        System.out.println("Duty: " + dutyName);
        System.out.println("Assigned employees:");

        if (assigned.isEmpty()) {
            System.out.println("(None assigned)");
            return;
        }

        for (Employee e : assigned) {
            System.out.println("- " + e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName);
        }
    }

    static void reportDutyCountsForSection(Scanner sc, Store st) {
        System.out.println("\n=== DUTY COUNTS (SECTION) ===");
        if (st.sections.isEmpty()) { System.out.println("(No sections)"); return; }

        listSections(st);
        String secId = Input.readStringAllowBack(sc, "Section ID (or b): ");
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }

        System.out.println("\nSection: " + st.formatSectionChain(sec.sectionId));

        if (sec.dutyNames.isEmpty()) {
            System.out.println("(No duties defined)");
            return;
        }

        for (String d : sec.dutyNames) {
            int count = st.countEmployeesAssignedToDuty(sec.sectionId, d);
            System.out.println("- " + d + ": " + count);
        }
    }

    static void reportRateesForRater(Scanner sc, Store st) {
        System.out.println("\n=== RATEES FOR RATER ===");
        if (st.employees.isEmpty()) { System.out.println("(No employees)"); return; }

        listEmployees(st);
        String raterId = Input.readStringAllowBack(sc, "Rater Employee ID (or b): ");
        if (raterId == null) return;

        Employee r = st.findEmployee(raterId);
        if (r == null) { System.out.println("ERROR: Rater not found."); return; }

        System.out.println("Rater: " + r.employeeId + " | " + r.rank + " " + r.lastName + ", " + r.firstName);

        boolean any = false;
        for (Employee e : st.employees) {
            if (e.raterEmployeeId.equalsIgnoreCase(raterId)) {
                System.out.println("- " + e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName);
                any = true;
            }
        }
        if (!any) System.out.println("(No ratees assigned)");
    }

    static void reportEmployeesMissingRater(Store st) {
        System.out.println("\n=== EMPLOYEES MISSING RATER ===");
        if (st.employees.isEmpty()) { System.out.println("(No employees)"); return; }

        boolean any = false;
        for (Employee e : st.employees) {
            if (e.raterEmployeeId == null || e.raterEmployeeId.trim().isEmpty()) {
                System.out.println("- " + e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName);
                any = true;
            }
        }
        if (!any) System.out.println("(None)");
    }
}

/* ============================================================
 * ENUMS
 * ============================================================
 * Purpose:
 * - Defines allowed employment types
 */
enum EmploymentType { FULL_TIME, TRADITIONAL }

/* ============================================================
 * ORGANIZATION DATA CLASSES
 * ============================================================
 * Purpose:
 * - Stores Wing/Group/Squadron/Section records
 * - Parent relationships are stored as IDs on the child
 */
class Wing {
    String wingId;
    String name;
    Wing(String id, String name) { this.wingId = id; this.name = name; }
}

class Group {
    String groupId;
    String name;
    String wingId = "";
    Group(String id, String name) { this.groupId = id; this.name = name; }
}

class Squadron {
    String squadronId;
    String name;
    String groupId = "";
    Squadron(String id, String name) { this.squadronId = id; this.name = name; }
}

class Section {
    String sectionId;
    String name;
    String squadronId = "";
    ArrayList<String> dutyNames = new ArrayList<>();
    Section(String id, String name) { this.sectionId = id; this.name = name; }
}

/* ============================================================
 * EMPLOYEE + DUTY ASSIGNMENT DATA CLASSES
 * ============================================================
 * Purpose:
 * - Employee holds personal data + memberships + assignments
 * - DutyAssign ties a duty name to a specific Section
 */
class DutyAssign {
    String sectionId;
    String dutyName;
    DutyAssign(String s, String d) { sectionId = s; dutyName = d; }
}

class Employee {
    String employeeId;
    String rank = "";
    String firstName = "";
    String lastName = "";
    EmploymentType type = EmploymentType.FULL_TIME;
    int skillLevel = 0;

    // Notes:
    // - Stores the rater as another employeeId.
    // - Ratees are found by searching for employees who point to this rater ID.
    String raterEmployeeId = "";

    // Notes:
    // - Employees can belong to multiple sections.
    ArrayList<String> sectionIds = new ArrayList<>();

    // Notes:
    // - A duty assignment only makes sense if:
    //   - the duty exists in the section's dutyNames list
    //   - the employee belongs to that section
    ArrayList<DutyAssign> dutyAssignments = new ArrayList<>();

    Employee(String id) { employeeId = id; }
}

/* ============================================================
 * DATA STORE + FILE STORAGE
 * ============================================================
 * Purpose:
 * - Stores all in-memory lists
 * - Loads from CSV into lists
 * - Saves lists back to CSV
 * - Reconciles records after load to remove invalid references
 *
 * Notes:
 * - CSV files are created automatically if missing.
 * - Data is stored using simple comma-separated lines (no quoted commas).
 */
class Store {

    ArrayList<Wing> wings = new ArrayList<>();
    ArrayList<Group> groups = new ArrayList<>();
    ArrayList<Squadron> squadrons = new ArrayList<>();
    ArrayList<Section> sections = new ArrayList<>();
    ArrayList<Employee> employees = new ArrayList<>();

    final String WINGS = "wings.csv";
    final String GROUPS = "groups.csv";
    final String SQUADS = "squadrons.csv";
    final String SECTS = "sections.csv";
    final String EMPS = "employees.csv";

    // ============================================================
    // FIND HELPERS
    // ============================================================

    Wing findWing(String id) { for (Wing w : wings) if (w.wingId.equalsIgnoreCase(id)) return w; return null; }
    Group findGroup(String id) { for (Group g : groups) if (g.groupId.equalsIgnoreCase(id)) return g; return null; }
    Squadron findSquadron(String id) { for (Squadron s : squadrons) if (s.squadronId.equalsIgnoreCase(id)) return s; return null; }
    Section findSection(String id) { for (Section s : sections) if (s.sectionId.equalsIgnoreCase(id)) return s; return null; }
    Employee findEmployee(String id) { for (Employee e : employees) if (e.employeeId.equalsIgnoreCase(id)) return e; return null; }

    // ============================================================
    // DUTY REPORT HELPERS
    // ============================================================

    int countEmployeesAssignedToDuty(String sectionId, String dutyName) {
        int count = 0;
        for (Employee e : employees) {
            for (DutyAssign a : e.dutyAssignments) {
                if (a.sectionId.equalsIgnoreCase(sectionId) && a.dutyName.equalsIgnoreCase(dutyName)) {
                    count++;
                    break;
                }
            }
        }
        return count;
    }

    ArrayList<Employee> findEmployeesAssignedToDuty(String sectionId, String dutyName) {
        ArrayList<Employee> out = new ArrayList<>();
        for (Employee e : employees) {
            for (DutyAssign a : e.dutyAssignments) {
                if (a.sectionId.equalsIgnoreCase(sectionId) && a.dutyName.equalsIgnoreCase(dutyName)) {
                    out.add(e);
                    break;
                }
            }
        }
        return out;
    }

    // ============================================================
    // VALIDATION HELPERS
    // ============================================================

    boolean containsIgnoreCase(List<String> list, String value) {
        for (String s : list) if (s.equalsIgnoreCase(value)) return true;
        return false;
    }

    boolean sectionHasDuty(String sectionId, String dutyName) {
        Section sec = findSection(sectionId);
        if (sec == null) return false;
        for (String d : sec.dutyNames) if (d.equalsIgnoreCase(dutyName)) return true;
        return false;
    }

    boolean employeeHasDuty(Employee e, String sectionId, String dutyName) {
        for (DutyAssign a : e.dutyAssignments) {
            if (a.sectionId.equalsIgnoreCase(sectionId) && a.dutyName.equalsIgnoreCase(dutyName)) return true;
        }
        return false;
    }

    // ============================================================
    // DISPLAY HELPER
    // ============================================================
    // Notes:
    // - Builds a human-readable chain: Section -> Squadron -> Group -> Wing
    // - If any link is missing, it shows UNASSIGNED for that level.
    String formatSectionChain(String sectionId) {
        Section sec = findSection(sectionId);
        if (sec == null) return sectionId + " (missing section record)";

        String squadPart = "UNASSIGNED";
        String groupPart = "UNASSIGNED";
        String wingPart = "UNASSIGNED";

        if (!sec.squadronId.isEmpty()) {
            Squadron sq = findSquadron(sec.squadronId);
            if (sq != null) {
                squadPart = sq.squadronId + " " + sq.name;

                if (!sq.groupId.isEmpty()) {
                    Group g = findGroup(sq.groupId);
                    if (g != null) {
                        groupPart = g.groupId + " " + g.name;

                        if (!g.wingId.isEmpty()) {
                            Wing w = findWing(g.wingId);
                            if (w != null) wingPart = w.wingId + " " + w.name;
                        }
                    }
                }
            }
        }

        return sec.sectionId + " " + sec.name + " | Sq: " + squadPart + " | Gp: " + groupPart + " | Wg: " + wingPart;
    }

    // ============================================================
    // LOAD/SAVE DRIVER METHODS
    // ============================================================

    void loadAll() {
        ensureFileExists(WINGS);
        ensureFileExists(GROUPS);
        ensureFileExists(SQUADS);
        ensureFileExists(SECTS);
        ensureFileExists(EMPS);

        loadWings();
        loadGroups();
        loadSquads();
        loadSects();
        loadEmps();

        reconcile();
    }

    void saveAll() {
        saveWings();
        saveGroups();
        saveSquads();
        saveSects();
        saveEmps();
    }

    // ============================================================
    // STRING SANITIZING (CSV + PIPE ENCODING)
    // ============================================================

    // Notes:
    // - Removes or replaces characters that can break our file formats.
    // - This keeps commas from splitting fields unexpectedly.
    // - It also keeps our internal separators (| and :) from breaking decoding.
    static String clean(String s) {
        if (s == null) return "";
        String t = s.trim();
        t = t.replace(",", " ");
        t = t.replace("|", "/");
        t = t.replace(":", "/");
        return t;
    }

    static String joinPipe(List<String> list) {
        if (list == null || list.isEmpty()) return "";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < list.size(); i++) {
            sb.append(clean(list.get(i)));
            if (i < list.size() - 1) sb.append("|");
        }
        return sb.toString();
    }

    static ArrayList<String> splitPipe(String s) {
        ArrayList<String> out = new ArrayList<>();
        if (s == null) return out;
        String t = s.trim();
        if (t.isEmpty()) return out;

        String[] parts = t.split("\\|", -1);
        for (String p : parts) {
            String v = p.trim();
            if (!v.isEmpty()) out.add(v);
        }
        return out;
    }

    static String encodeDutyAssign(List<DutyAssign> list) {
        if (list == null || list.isEmpty()) return "";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < list.size(); i++) {
            DutyAssign a = list.get(i);
            sb.append(clean(a.sectionId)).append(":").append(clean(a.dutyName));
            if (i < list.size() - 1) sb.append("|");
        }
        return sb.toString();
    }

    static ArrayList<DutyAssign> decodeDutyAssign(String s) {
        ArrayList<DutyAssign> out = new ArrayList<>();
        if (s == null) return out;
        String t = s.trim();
        if (t.isEmpty()) return out;

        String[] parts = t.split("\\|", -1);
        for (String item : parts) {
            String x = item.trim();
            if (x.isEmpty()) continue;

            String[] kv = x.split(":", -1);
            if (kv.length >= 2) {
                String secId = kv[0].trim();
                String duty = kv[1].trim();
                if (!secId.isEmpty() && !duty.isEmpty()) out.add(new DutyAssign(secId, duty));
            }
        }
        return out;
    }

    // ============================================================
    // RECONCILE
    // ============================================================
    // Purpose:
    // - Cleans up bad references after loading:
    //   - removes section memberships that no longer exist
    //   - removes duty assignments that are invalid
    //   - clears rater references that point to missing employees
    void reconcile() {
        for (Employee e : employees) {
            e.sectionIds.removeIf(sid -> findSection(sid) == null);

            e.dutyAssignments.removeIf(a -> findSection(a.sectionId) == null);
            e.dutyAssignments.removeIf(a -> !containsIgnoreCase(e.sectionIds, a.sectionId));
            e.dutyAssignments.removeIf(a -> !sectionHasDuty(a.sectionId, a.dutyName));

            if (!e.raterEmployeeId.isEmpty() && findEmployee(e.raterEmployeeId) == null) e.raterEmployeeId = "";
            if (e.raterEmployeeId.equalsIgnoreCase(e.employeeId)) e.raterEmployeeId = "";
        }
    }

    // ============================================================
    // FILE EXISTENCE
    // ============================================================

    void ensureFileExists(String fileName) {
        File f = new File(fileName);
        if (f.exists()) return;

        try {
            f.createNewFile();
        } catch (Exception ex) {
            System.out.println("ERROR: Could not create " + fileName + ".");
        }
    }

    // ============================================================
    // LOAD METHODS
    // ============================================================

    void loadWings() {
        wings = loadTwoColumnRecords(WINGS, (a, b) -> new Wing(a, b));
    }

    void loadGroups() {
        groups.clear();
        for (String[] p : readCsv(GROUPS)) {
            if (p.length >= 2) {
                Group g = new Group(p[0], p[1]);
                if (p.length >= 3) g.wingId = p[2];
                groups.add(g);
            }
        }
    }

    void loadSquads() {
        squadrons.clear();
        for (String[] p : readCsv(SQUADS)) {
            if (p.length >= 2) {
                Squadron s = new Squadron(p[0], p[1]);
                if (p.length >= 3) s.groupId = p[2];
                squadrons.add(s);
            }
        }
    }

    void loadSects() {
        sections.clear();
        for (String[] p : readCsv(SECTS)) {
            if (p.length >= 2) {
                Section s = new Section(p[0], p[1]);
                if (p.length >= 3) s.squadronId = p[2];
                if (p.length >= 4) s.dutyNames = splitPipe(p[3]);
                sections.add(s);
            }
        }
    }

    void loadEmps() {
        employees.clear();
        for (String[] p : readCsv(EMPS)) {
            if (p.length >= 6) {
                Employee e = new Employee(p[0]);
                e.rank = p[1];
                e.firstName = p[2];
                e.lastName = p[3];

                try { e.type = EmploymentType.valueOf(p[4]); }
                catch (Exception ex) { e.type = EmploymentType.FULL_TIME; }

                try { e.skillLevel = Integer.parseInt(p[5]); }
                catch (Exception ex) { e.skillLevel = 0; }

                if (p.length >= 7) e.raterEmployeeId = p[6];
                if (p.length >= 8) e.sectionIds = splitPipe(p[7]);
                if (p.length >= 9) e.dutyAssignments = decodeDutyAssign(p[8]);

                employees.add(e);
            }
        }
    }

    // ============================================================
    // SAVE METHODS
    // ============================================================

    void saveWings() {
        saveTwoColumnRecords(WINGS, wings, w -> new String[]{w.wingId, w.name});
    }

    void saveGroups() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (Group g : groups) rows.add(new String[]{g.groupId, g.name, g.wingId});
        writeCsv(GROUPS, rows);
    }

    void saveSquads() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (Squadron s : squadrons) rows.add(new String[]{s.squadronId, s.name, s.groupId});
        writeCsv(SQUADS, rows);
    }

    void saveSects() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (Section s : sections) rows.add(new String[]{s.sectionId, s.name, s.squadronId, joinPipe(s.dutyNames)});
        writeCsv(SECTS, rows);
    }

    void saveEmps() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (Employee e : employees) {
            rows.add(new String[]{
                    e.employeeId,
                    e.rank,
                    e.firstName,
                    e.lastName,
                    e.type.toString(),
                    String.valueOf(e.skillLevel),
                    e.raterEmployeeId,
                    joinPipe(e.sectionIds),
                    encodeDutyAssign(e.dutyAssignments)
            });
        }
        writeCsv(EMPS, rows);
    }

    // ============================================================
    // GENERIC CSV UTILITIES
    // ============================================================

    interface TwoColumnFactory<T> { T create(String a, String b); }
    interface RecordSerializer<T> { String[] toRow(T t); }

    <T> ArrayList<T> loadTwoColumnRecords(String file, TwoColumnFactory<T> factory) {
        ArrayList<T> out = new ArrayList<>();
        for (String[] p : readCsv(file)) if (p.length >= 2) out.add(factory.create(p[0], p[1]));
        return out;
    }

    <T> void saveTwoColumnRecords(String file, List<T> list, RecordSerializer<T> serializer) {
        ArrayList<String[]> rows = new ArrayList<>();
        for (T t : list) rows.add(serializer.toRow(t));
        writeCsv(file, rows);
    }

    ArrayList<String[]> readCsv(String file) {
        ArrayList<String[]> rows = new ArrayList<>();

        ensureFileExists(file);

        try (BufferedReader br = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = br.readLine()) != null) {
                String[] p = line.split(",", -1);
                for (int i = 0; i < p.length; i++) p[i] = p[i].trim();
                rows.add(p);
            }
        } catch (Exception ex) {
            System.out.println("ERROR: Could not read " + file + ".");
        }

        return rows;
    }

    void writeCsv(String file, ArrayList<String[]> rows) {
        ensureFileExists(file);

        try (BufferedWriter bw = new BufferedWriter(new FileWriter(file))) {
            for (String[] r : rows) {
                for (int i = 0; i < r.length; i++) {
                    bw.write(clean(r[i]));
                    if (i < r.length - 1) bw.write(",");
                }
                bw.newLine();
            }
        } catch (Exception ex) {
            System.out.println("ERROR: Could not save " + file + ".");
        }
    }
}
