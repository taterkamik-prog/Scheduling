import java.io.*;
import java.time.*;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.time.temporal.TemporalAdjusters;
import java.util.*;

/* ============================================================
 * PROGRAM ENTRY POINT
 * ============================================================
 * This program manages:
 * - Organization: Wings, Groups, Squadrons, Sections
 * - Employees with rater/ratee
 * - Section-specific additional duties + assignments
 * - Shift schedules (weekly + rotating) and teams
 * - Scheduling events (appointments, training, TDY, leave, etc.)
 * - Shift generation from schedules (SHIFT events)
 * - Drill days and traditional availability tracking
 * - Views: daily, weekly, monthly, hourly, shift coverage
 * - Reports and availability dashboard
 */
public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        Store store = new Store();
        store.loadAll();

        while (true) {
            System.out.println("\n=== MAIN MENU ===");
            System.out.println("1) Organization");
            System.out.println("2) Employees");
            System.out.println("3) Additional Duties (by Section)");
            System.out.println("4) Scheduling");
            System.out.println("5) Reports");
            System.out.println("6) Save");
            System.out.println("7) Save & Exit");

            Integer choice = Input.readInt(sc, "Choice: ", true);
            if (choice == null) continue;

            if (choice == 1) Menus.organization(sc, store);
            else if (choice == 2) Menus.employees(sc, store);
            else if (choice == 3) Menus.duties(sc, store);
            else if (choice == 4) Menus.scheduling(sc, store);
            else if (choice == 5) Menus.reports(sc, store);
            else if (choice == 6) { store.saveAll(); System.out.println("Saved."); }
            else if (choice == 7) { store.saveAll(); System.out.println("Saved. Exiting."); break; }
            else System.out.println("ERROR: Invalid choice.");
        }

        sc.close();
    }
}

/* ============================================================
 * MENU CONTROLLER
 * ============================================================
 */
class Menus {

    /* ============================================================
     * ORGANIZATION MENU
     * ============================================================
     */
    static void organization(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- ORGANIZATION ---");
            System.out.println("1) Create Wing");
            System.out.println("2) Create Group");
            System.out.println("3) Create Squadron");
            System.out.println("4) Create Section");
            System.out.println("5) Edit Wing Name");
            System.out.println("6) Edit Group Name");
            System.out.println("7) Edit Squadron Name");
            System.out.println("8) Edit Section Name");
            System.out.println("9) Delete Wing");
            System.out.println("10) Delete Group");
            System.out.println("11) Delete Squadron");
            System.out.println("12) Delete Section");
            System.out.println("13) Assign Group -> Wing");
            System.out.println("14) Assign Squadron -> Group");
            System.out.println("15) Assign Section -> Squadron");
            System.out.println("16) List All");
            System.out.println("17) Back");

            Integer c = Input.readInt(sc, "Choice: ", true);
            if (c == null) continue;

            if (c == 1) createWing(sc, st);
            else if (c == 2) createGroup(sc, st);
            else if (c == 3) createSquadron(sc, st);
            else if (c == 4) createSection(sc, st);
            else if (c == 5) editWing(sc, st);
            else if (c == 6) editGroup(sc, st);
            else if (c == 7) editSquadron(sc, st);
            else if (c == 8) editSection(sc, st);
            else if (c == 9) deleteWing(sc, st);
            else if (c == 10) deleteGroup(sc, st);
            else if (c == 11) deleteSquadron(sc, st);
            else if (c == 12) deleteSection(sc, st);
            else if (c == 13) assignGroupToWing(sc, st);
            else if (c == 14) assignSquadronToGroup(sc, st);
            else if (c == 15) assignSectionToSquadron(sc, st);
            else if (c == 16) listOrg(st);
            else if (c == 17) return;
            else System.out.println("ERROR: Invalid choice.");
        }
    }

    /* ============================================================
     * EMPLOYEE MENU
     * ============================================================
     */
    static void employees(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- EMPLOYEES ---");
            System.out.println("1) Add Employee");
            System.out.println("2) Edit Employee");
            System.out.println("3) Delete Employee");
            System.out.println("4) List Employees");
            System.out.println("5) View Employee Details");
            System.out.println("6) Assign Employee to Section");
            System.out.println("7) Remove Employee from Section");
            System.out.println("8) Assign Additional Duty (Employee)");
            System.out.println("9) Remove Additional Duty (Employee)");
            System.out.println("10) Set/Clear Assigned Rater");
            System.out.println("11) Set/Clear Shift Team");
            System.out.println("12) Back");

            Integer c = Input.readInt(sc, "Choice: ", true);
            if (c == null) continue;

            if (c == 1) addEmployee(sc, st);
            else if (c == 2) editEmployee(sc, st);
            else if (c == 3) deleteEmployee(sc, st);
            else if (c == 4) listEmployees(st);
            else if (c == 5) viewEmployeeDetails(sc, st);
            else if (c == 6) assignEmpToSection(sc, st);
            else if (c == 7) removeEmpFromSection(sc, st);
            else if (c == 8) assignDutyToEmployee(sc, st);
            else if (c == 9) removeDutyFromEmployee(sc, st);
            else if (c == 10) setRater(sc, st);
            else if (c == 11) setShiftTeam(sc, st);
            else if (c == 12) return;
            else System.out.println("ERROR: Invalid choice.");
        }
    }

    /* ============================================================
     * DUTIES MENU
     * ============================================================
     */
    static void duties(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- ADDITIONAL DUTIES (BY SECTION) ---");
            System.out.println("1) View Duties for Section");
            System.out.println("2) Add Duty to Section");
            System.out.println("3) Rename Duty in Section");
            System.out.println("4) Delete Duty from Section");
            System.out.println("5) Back");

            Integer c = Input.readInt(sc, "Choice: ", true);
            if (c == null) continue;

            if (c == 1) viewSectionDuties(sc, st);
            else if (c == 2) addDutyToSection(sc, st);
            else if (c == 3) renameDutyInSection(sc, st);
            else if (c == 4) deleteDutyFromSection(sc, st);
            else if (c == 5) return;
            else System.out.println("ERROR: Invalid choice.");
        }
    }

    /* ============================================================
     * SCHEDULING MENU
     * ============================================================
     */
    static void scheduling(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- SCHEDULING ---");
            System.out.println("1) Shift Schedules");
            System.out.println("2) Shift Teams");
            System.out.println("3) Apply Team Schedule to Date Range (Generate Shifts)");
            System.out.println("4) Remove Team Shifts from Date Range");
            System.out.println("5) Calendar Events (Create/Edit/Delete)");
            System.out.println("6) Drill Days and Drill Availability");
            System.out.println("7) Views");
            System.out.println("8) Back");

            Integer c = Input.readInt(sc, "Choice: ", true);
            if (c == null) continue;

            if (c == 1) shiftSchedules(sc, st);
            else if (c == 2) shiftTeams(sc, st);
            else if (c == 3) applyTeamSchedule(sc, st);
            else if (c == 4) removeTeamShifts(sc, st);
            else if (c == 5) eventsMenu(sc, st);
            else if (c == 6) drillMenu(sc, st);
            else if (c == 7) viewsMenu(sc, st);
            else if (c == 8) return;
            else System.out.println("ERROR: Invalid choice.");
        }
    }

    /* ============================================================
     * REPORTS MENU
     * ============================================================
     */
    static void reports(Scanner sc, Store st) {
        while (true) {
            System.out.println("\n--- REPORTS ---");
            System.out.println("1) Duty Counts by Section");
            System.out.println("2) Duty Assignments by Employee");
            System.out.println("3) Who Holds a Duty (Duty -> People)");
            System.out.println("4) Rater/Ratee Report");
            System.out.println("5) Availability Dashboard (by Date)");
            System.out.println("6) Back");

            Integer c = Input.readInt(sc, "Choice: ", true);
            if (c == null) continue;

            if (c == 1) reportDutyCounts(st);
            else if (c == 2) reportDutiesByEmployee(st);
            else if (c == 3) reportWhoHoldsDuty(sc, st);
            else if (c == 4) reportRaters(st);
            else if (c == 5) availabilityDashboard(sc, st);
            else if (c == 6) return;
            else System.out.println("ERROR: Invalid choice.");
        }
    }

    /* ============================================================
     * ORGANIZATION CRUD
     * ============================================================
     */
    static void createWing(Scanner sc, Store st) {
        String id = Input.readString(sc, "Wing ID (blank cancels): ", true);
        if (id == null) return;
        if (st.findWing(id) != null) { System.out.println("ERROR: Wing ID exists."); return; }
        String name = Input.readString(sc, "Wing Name (blank cancels): ", true);
        if (name == null) return;
        st.wings.add(new Wing(id, name));
        System.out.println("SUCCESS.");
    }

    static void createGroup(Scanner sc, Store st) {
        String id = Input.readString(sc, "Group ID (blank cancels): ", true);
        if (id == null) return;
        if (st.findGroup(id) != null) { System.out.println("ERROR: Group ID exists."); return; }
        String name = Input.readString(sc, "Group Name (blank cancels): ", true);
        if (name == null) return;
        st.groups.add(new Group(id, name));
        System.out.println("SUCCESS.");
    }

    static void createSquadron(Scanner sc, Store st) {
        String id = Input.readString(sc, "Squadron ID (blank cancels): ", true);
        if (id == null) return;
        if (st.findSquadron(id) != null) { System.out.println("ERROR: Squadron ID exists."); return; }
        String name = Input.readString(sc, "Squadron Name (blank cancels): ", true);
        if (name == null) return;
        st.squadrons.add(new Squadron(id, name));
        System.out.println("SUCCESS.");
    }

    static void createSection(Scanner sc, Store st) {
        String id = Input.readString(sc, "Section ID (blank cancels): ", true);
        if (id == null) return;
        if (st.findSection(id) != null) { System.out.println("ERROR: Section ID exists."); return; }
        String name = Input.readString(sc, "Section Name (blank cancels): ", true);
        if (name == null) return;
        st.sections.add(new Section(id, name));
        System.out.println("SUCCESS.");
    }

    static void editWing(Scanner sc, Store st) {
        listWings(st);
        String id = Input.readString(sc, "Wing ID (blank cancels): ", true);
        if (id == null) return;
        Wing w = st.findWing(id);
        if (w == null) { System.out.println("ERROR: Wing not found."); return; }
        String name = Input.readString(sc, "New Name (blank cancels): ", true);
        if (name == null) return;
        w.name = name;
        System.out.println("SUCCESS.");
    }

    static void editGroup(Scanner sc, Store st) {
        listGroups(st);
        String id = Input.readString(sc, "Group ID (blank cancels): ", true);
        if (id == null) return;
        Group g = st.findGroup(id);
        if (g == null) { System.out.println("ERROR: Group not found."); return; }
        String name = Input.readString(sc, "New Name (blank cancels): ", true);
        if (name == null) return;
        g.name = name;
        System.out.println("SUCCESS.");
    }

    static void editSquadron(Scanner sc, Store st) {
        listSquadrons(st);
        String id = Input.readString(sc, "Squadron ID (blank cancels): ", true);
        if (id == null) return;
        Squadron s = st.findSquadron(id);
        if (s == null) { System.out.println("ERROR: Squadron not found."); return; }
        String name = Input.readString(sc, "New Name (blank cancels): ", true);
        if (name == null) return;
        s.name = name;
        System.out.println("SUCCESS.");
    }

    static void editSection(Scanner sc, Store st) {
        listSections(st);
        String id = Input.readString(sc, "Section ID (blank cancels): ", true);
        if (id == null) return;
        Section s = st.findSection(id);
        if (s == null) { System.out.println("ERROR: Section not found."); return; }
        String name = Input.readString(sc, "New Name (blank cancels): ", true);
        if (name == null) return;
        s.name = name;
        System.out.println("SUCCESS.");
    }

    static void deleteWing(Scanner sc, Store st) {
        listWings(st);
        String id = Input.readString(sc, "Wing ID (blank cancels): ", true);
        if (id == null) return;
        Wing w = st.findWing(id);
        if (w == null) { System.out.println("ERROR: Wing not found."); return; }
        for (Group g : st.groups) if (g.wingId.equalsIgnoreCase(id)) g.wingId = "";
        st.wings.remove(w);
        System.out.println("SUCCESS: Deleted. Groups unassigned.");
    }

    static void deleteGroup(Scanner sc, Store st) {
        listGroups(st);
        String id = Input.readString(sc, "Group ID (blank cancels): ", true);
        if (id == null) return;
        Group g = st.findGroup(id);
        if (g == null) { System.out.println("ERROR: Group not found."); return; }
        for (Squadron sq : st.squadrons) if (sq.groupId.equalsIgnoreCase(id)) sq.groupId = "";
        st.groups.remove(g);
        System.out.println("SUCCESS: Deleted. Squadrons unassigned.");
    }

    static void deleteSquadron(Scanner sc, Store st) {
        listSquadrons(st);
        String id = Input.readString(sc, "Squadron ID (blank cancels): ", true);
        if (id == null) return;
        Squadron s = st.findSquadron(id);
        if (s == null) { System.out.println("ERROR: Squadron not found."); return; }
        for (Section sec : st.sections) if (sec.squadronId.equalsIgnoreCase(id)) sec.squadronId = "";
        st.squadrons.remove(s);
        System.out.println("SUCCESS: Deleted. Sections unassigned.");
    }

    static void deleteSection(Scanner sc, Store st) {
        listSections(st);
        String id = Input.readString(sc, "Section ID (blank cancels): ", true);
        if (id == null) return;
        Section sec = st.findSection(id);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }

        for (Employee e : st.employees) {
            e.sectionIds.removeIf(sid -> sid.equalsIgnoreCase(id));
            e.dutyAssignments.removeIf(a -> a.sectionId.equalsIgnoreCase(id));
        }

        st.sections.remove(sec);
        System.out.println("SUCCESS: Deleted. Employee memberships/duties removed.");
    }

    static void assignGroupToWing(Scanner sc, Store st) {
        listGroups(st);
        String gid = Input.readString(sc, "Group ID (blank cancels): ", true);
        if (gid == null) return;
        Group g = st.findGroup(gid);
        if (g == null) { System.out.println("ERROR: Group not found."); return; }

        listWings(st);
        String wid = Input.readString(sc, "Wing ID (blank to unassign): ", true);
        if (wid == null) return;
        if (wid.isEmpty()) { g.wingId = ""; System.out.println("SUCCESS: Unassigned."); return; }

        Wing w = st.findWing(wid);
        if (w == null) { System.out.println("ERROR: Wing not found."); return; }

        g.wingId = w.wingId;
        System.out.println("SUCCESS.");
    }

    static void assignSquadronToGroup(Scanner sc, Store st) {
        listSquadrons(st);
        String sid = Input.readString(sc, "Squadron ID (blank cancels): ", true);
        if (sid == null) return;
        Squadron sq = st.findSquadron(sid);
        if (sq == null) { System.out.println("ERROR: Squadron not found."); return; }

        listGroups(st);
        String gid = Input.readString(sc, "Group ID (blank to unassign): ", true);
        if (gid == null) return;
        if (gid.isEmpty()) { sq.groupId = ""; System.out.println("SUCCESS: Unassigned."); return; }

        Group g = st.findGroup(gid);
        if (g == null) { System.out.println("ERROR: Group not found."); return; }

        sq.groupId = g.groupId;
        System.out.println("SUCCESS.");
    }

    static void assignSectionToSquadron(Scanner sc, Store st) {
        listSections(st);
        String secId = Input.readString(sc, "Section ID (blank cancels): ", true);
        if (secId == null) return;
        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }

        listSquadrons(st);
        String sqId = Input.readString(sc, "Squadron ID (blank to unassign): ", true);
        if (sqId == null) return;
        if (sqId.isEmpty()) { sec.squadronId = ""; System.out.println("SUCCESS: Unassigned."); return; }

        Squadron sq = st.findSquadron(sqId);
        if (sq == null) { System.out.println("ERROR: Squadron not found."); return; }

        sec.squadronId = sq.squadronId;
        System.out.println("SUCCESS.");
    }

    static void listOrg(Store st) {
        System.out.println("\nWINGS"); listWings(st);
        System.out.println("\nGROUPS"); listGroups(st);
        System.out.println("\nSQUADRONS"); listSquadrons(st);
        System.out.println("\nSECTIONS"); listSections(st);
    }

    static void listWings(Store st) {
        if (st.wings.isEmpty()) { System.out.println("(None)"); return; }
        for (Wing w : st.wings) System.out.println(w.wingId + " | " + w.name);
    }

    static void listGroups(Store st) {
        if (st.groups.isEmpty()) { System.out.println("(None)"); return; }
        for (Group g : st.groups) {
            System.out.println(g.groupId + " | " + g.name + " | Wing: " + (g.wingId.isEmpty() ? "UNASSIGNED" : g.wingId));
        }
    }

    static void listSquadrons(Store st) {
        if (st.squadrons.isEmpty()) { System.out.println("(None)"); return; }
        for (Squadron s : st.squadrons) {
            System.out.println(s.squadronId + " | " + s.name + " | Group: " + (s.groupId.isEmpty() ? "UNASSIGNED" : s.groupId));
        }
    }

    static void listSections(Store st) {
        if (st.sections.isEmpty()) { System.out.println("(None)"); return; }
        for (Section s : st.sections) {
            System.out.println(s.sectionId + " | " + s.name + " | Squadron: " + (s.squadronId.isEmpty() ? "UNASSIGNED" : s.squadronId));
        }
    }

    /* ============================================================
     * EMPLOYEE CRUD + DETAILS
     * ============================================================
     */
    static void addEmployee(Scanner sc, Store st) {
        String id = Input.readString(sc, "Employee ID (blank cancels): ", true);
        if (id == null) return;
        if (st.findEmployee(id) != null) { System.out.println("ERROR: Employee ID exists."); return; }

        Employee e = new Employee(id);

        String rank = Input.readString(sc, "Rank (blank cancels): ", true);
        if (rank == null) return;
        String first = Input.readString(sc, "First Name (blank cancels): ", true);
        if (first == null) return;
        String last = Input.readString(sc, "Last Name (blank cancels): ", true);
        if (last == null) return;
        EmploymentType type = Input.readEnum(sc, "Employment Type (FULL_TIME/TRADITIONAL) (blank cancels): ", EmploymentType.class, true);
        if (type == null) return;
        Integer skill = Input.readInt(sc, "Skill Level (blank cancels): ", true);
        if (skill == null) return;

        e.rank = rank;
        e.firstName = first;
        e.lastName = last;
        e.type = type;
        e.skillLevel = skill;

        st.employees.add(e);
        System.out.println("SUCCESS.");
    }

    static void editEmployee(Scanner sc, Store st) {
        listEmployees(st);
        String id = Input.readString(sc, "Employee ID (blank cancels): ", true);
        if (id == null) return;

        Employee e = st.findEmployee(id);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        while (true) {
            System.out.println("\nEdit: " + e.employeeId + " (" + e.rank + " " + e.lastName + ")");
            System.out.println("1) Rank");
            System.out.println("2) First Name");
            System.out.println("3) Last Name");
            System.out.println("4) Employment Type");
            System.out.println("5) Skill Level");
            System.out.println("6) Back");

            Integer f = Input.readInt(sc, "Field: ", true);
            if (f == null) continue;

            if (f == 1) {
                String v = Input.readString(sc, "New Rank (blank cancels): ", true);
                if (v != null) e.rank = v;
            } else if (f == 2) {
                String v = Input.readString(sc, "New First Name (blank cancels): ", true);
                if (v != null) e.firstName = v;
            } else if (f == 3) {
                String v = Input.readString(sc, "New Last Name (blank cancels): ", true);
                if (v != null) e.lastName = v;
            } else if (f == 4) {
                EmploymentType v = Input.readEnum(sc, "Employment Type (FULL_TIME/TRADITIONAL) (blank cancels): ", EmploymentType.class, true);
                if (v != null) e.type = v;
            } else if (f == 5) {
                Integer v = Input.readInt(sc, "New Skill Level (blank cancels): ", true);
                if (v != null) e.skillLevel = v;
            } else if (f == 6) {
                return;
            }
        }
    }

    static void deleteEmployee(Scanner sc, Store st) {
        listEmployees(st);
        String id = Input.readString(sc, "Employee ID (blank cancels): ", true);
        if (id == null) return;

        Employee e = st.findEmployee(id);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        for (Employee other : st.employees) {
            if (other.raterEmployeeId.equalsIgnoreCase(id)) other.raterEmployeeId = "";
        }

        st.events.removeIf(ev -> !ev.isGlobal() && ev.employeeIdOrNull.equalsIgnoreCase(id));
        st.drillAvailabilityList.removeIf(da -> da.employeeId.equalsIgnoreCase(id));

        st.employees.remove(e);
        System.out.println("SUCCESS.");
    }

    static void listEmployees(Store st) {
        System.out.println("\nEMPLOYEES");
        if (st.employees.isEmpty()) { System.out.println("(None)"); return; }
        for (Employee e : st.employees) {
            String team = e.shiftTeamId.isEmpty() ? "NO TEAM" : e.shiftTeamId;
            System.out.println(e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName +
                    " | " + e.type + " | Skill " + e.skillLevel + " | Team: " + team);
        }
    }

    static void viewEmployeeDetails(Scanner sc, Store st) {
        listEmployees(st);
        String id = Input.readString(sc, "Employee ID (blank cancels): ", true);
        if (id == null) return;

        Employee e = st.findEmployee(id);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        System.out.println("\nDETAILS: " + e.employeeId);
        System.out.println("Name: " + e.rank + " " + e.firstName + " " + e.lastName);
        System.out.println("Type: " + e.type);
        System.out.println("Skill: " + e.skillLevel);

        if (e.shiftTeamId.isEmpty()) {
            System.out.println("Shift Team: (None)");
        } else {
            ShiftTeam t = st.findShiftTeam(e.shiftTeamId);
            System.out.println("Shift Team: " + e.shiftTeamId + (t == null ? " (missing record)" : " (" + t.name + ")"));
        }

        if (e.raterEmployeeId.isEmpty()) {
            System.out.println("Rater: (None)");
        } else {
            Employee r = st.findEmployee(e.raterEmployeeId);
            System.out.println("Rater: " + e.raterEmployeeId + (r == null ? " (missing record)" : " (" + r.rank + " " + r.lastName + ")"));
        }

        System.out.println("\nSections:");
        if (e.sectionIds.isEmpty()) System.out.println("(None)");
        else for (String sid : e.sectionIds) System.out.println(" - " + st.formatSectionChain(sid));

        System.out.println("\nAdditional Duties:");
        if (e.dutyAssignments.isEmpty()) System.out.println("(None)");
        else for (DutyAssign a : e.dutyAssignments) System.out.println(" - " + st.formatSectionChain(a.sectionId) + " => " + a.dutyName);
    }

    static void assignEmpToSection(Scanner sc, Store st) {
        listEmployees(st);
        String empId = Input.readString(sc, "Employee ID (blank cancels): ", true);
        if (empId == null) return;

        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        listSections(st);
        String secId = Input.readString(sc, "Section ID (blank cancels): ", true);
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }

        if (st.containsIgnoreCase(e.sectionIds, secId)) { System.out.println("ERROR: Already assigned."); return; }
        e.sectionIds.add(sec.sectionId);

        System.out.println("SUCCESS.");
    }

    static void removeEmpFromSection(Scanner sc, Store st) {
        listEmployees(st);
        String empId = Input.readString(sc, "Employee ID (blank cancels): ", true);
        if (empId == null) return;

        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        if (e.sectionIds.isEmpty()) { System.out.println("ERROR: Employee has no sections."); return; }

        System.out.println("Sections:");
        for (String sid : e.sectionIds) System.out.println(" - " + st.formatSectionChain(sid));

        String secId = Input.readString(sc, "Section ID to remove (blank cancels): ", true);
        if (secId == null) return;

        boolean removed = e.sectionIds.removeIf(sid -> sid.equalsIgnoreCase(secId));
        e.dutyAssignments.removeIf(a -> a.sectionId.equalsIgnoreCase(secId));

        if (!removed) { System.out.println("ERROR: Not a member of that section."); return; }
        System.out.println("SUCCESS.");
    }

    static void assignDutyToEmployee(Scanner sc, Store st) {
        listEmployees(st);
        String empId = Input.readString(sc, "Employee ID (blank cancels): ", true);
        if (empId == null) return;

        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        if (e.sectionIds.isEmpty()) { System.out.println("ERROR: Employee has no section memberships."); return; }

        System.out.println("Employee Sections:");
        for (String sid : e.sectionIds) System.out.println(" - " + st.formatSectionChain(sid));

        String secId = Input.readString(sc, "Section ID (blank cancels): ", true);
        if (secId == null) return;

        if (!st.containsIgnoreCase(e.sectionIds, secId)) { System.out.println("ERROR: Employee not in that section."); return; }

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }

        if (sec.dutyNames.isEmpty()) { System.out.println("ERROR: Section has no duties. Add in Duties menu."); return; }

        System.out.println("Section Duties:");
        for (String d : sec.dutyNames) System.out.println(" - " + d);

        String dutyName = Input.readString(sc, "Duty Name (exact) (blank cancels): ", true);
        if (dutyName == null) return;

        if (!st.sectionHasDuty(secId, dutyName)) { System.out.println("ERROR: Duty not defined for that section."); return; }
        if (st.employeeHasDuty(e, secId, dutyName)) { System.out.println("ERROR: Already assigned."); return; }

        e.dutyAssignments.add(new DutyAssign(sec.sectionId, dutyName));
        System.out.println("SUCCESS.");
    }

    static void removeDutyFromEmployee(Scanner sc, Store st) {
        listEmployees(st);
        String empId = Input.readString(sc, "Employee ID (blank cancels): ", true);
        if (empId == null) return;

        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        if (e.dutyAssignments.isEmpty()) { System.out.println("ERROR: No duty assignments."); return; }

        System.out.println("Current Assignments:");
        for (DutyAssign a : e.dutyAssignments) System.out.println(" - " + st.formatSectionChain(a.sectionId) + " => " + a.dutyName);

        String secId = Input.readString(sc, "Section ID (blank cancels): ", true);
        if (secId == null) return;

        String dutyName = Input.readString(sc, "Duty Name (exact) (blank cancels): ", true);
        if (dutyName == null) return;

        boolean removed = e.dutyAssignments.removeIf(a ->
                a.sectionId.equalsIgnoreCase(secId) && a.dutyName.equalsIgnoreCase(dutyName));

        if (!removed) { System.out.println("ERROR: Not assigned."); return; }
        System.out.println("SUCCESS.");
    }

    static void setRater(Scanner sc, Store st) {
        listEmployees(st);
        String empId = Input.readString(sc, "Employee ID to update (blank cancels): ", true);
        if (empId == null) return;

        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        System.out.println("Current rater: " + (e.raterEmployeeId.isEmpty() ? "(None)" : e.raterEmployeeId));
        String raterId = Input.readString(sc, "Rater Employee ID (blank to clear): ", true);
        if (raterId == null) return;

        if (raterId.isEmpty()) { e.raterEmployeeId = ""; System.out.println("SUCCESS."); return; }
        if (raterId.equalsIgnoreCase(empId)) { System.out.println("ERROR: Cannot be own rater."); return; }
        if (st.findEmployee(raterId) == null) { System.out.println("ERROR: Rater not found."); return; }

        e.raterEmployeeId = raterId;
        System.out.println("SUCCESS.");
    }

    static void setShiftTeam(Scanner sc, Store st) {
        listEmployees(st);
        String empId = Input.readString(sc, "Employee ID to update (blank cancels): ", true);
        if (empId == null) return;

        Employee e = st.findEmployee(empId);
        if (e == null) { System.out.println("ERROR: Employee not found."); return; }

        listShiftTeams(st);
        String teamId = Input.readString(sc, "Shift Team ID (blank to clear): ", true);
        if (teamId == null) return;

        if (teamId.isEmpty()) { e.shiftTeamId = ""; System.out.println("SUCCESS."); return; }
        if (st.findShiftTeam(teamId) == null) { System.out.println("ERROR: Team not found."); return; }

        e.shiftTeamId = teamId;
        System.out.println("SUCCESS.");
    }

    /* ============================================================
     * DUTIES CRUD
     * ============================================================
     */
    static void viewSectionDuties(Scanner sc, Store st) {
        listSections(st);
        String secId = Input.readString(sc, "Section ID (blank cancels): ", true);
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }

        System.out.println("\nDuties for " + sec.sectionId + " (" + sec.name + ")");
        if (sec.dutyNames.isEmpty()) System.out.println("(None)");
        else for (String d : sec.dutyNames) System.out.println(" - " + d);
    }

    static void addDutyToSection(Scanner sc, Store st) {
        listSections(st);
        String secId = Input.readString(sc, "Section ID (blank cancels): ", true);
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }

        String duty = Input.readString(sc, "Duty Name (blank cancels): ", true);
        if (duty == null) return;
        if (duty.isEmpty()) { System.out.println("ERROR: Blank duty name."); return; }
        if (st.sectionHasDuty(secId, duty)) { System.out.println("ERROR: Duty exists."); return; }

        sec.dutyNames.add(duty);
        System.out.println("SUCCESS.");
    }

    static void renameDutyInSection(Scanner sc, Store st) {
        listSections(st);
        String secId = Input.readString(sc, "Section ID (blank cancels): ", true);
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }
        if (sec.dutyNames.isEmpty()) { System.out.println("ERROR: No duties to rename."); return; }

        System.out.println("Duties:");
        for (String d : sec.dutyNames) System.out.println(" - " + d);

        String oldName = Input.readString(sc, "Old Duty Name (exact) (blank cancels): ", true);
        if (oldName == null) return;
        if (!st.sectionHasDuty(secId, oldName)) { System.out.println("ERROR: Duty not found."); return; }

        String newName = Input.readString(sc, "New Duty Name (blank cancels): ", true);
        if (newName == null) return;
        if (newName.isEmpty()) { System.out.println("ERROR: Blank duty name."); return; }
        if (st.sectionHasDuty(secId, newName)) { System.out.println("ERROR: New duty name already exists."); return; }

        for (int i = 0; i < sec.dutyNames.size(); i++) {
            if (sec.dutyNames.get(i).equalsIgnoreCase(oldName)) { sec.dutyNames.set(i, newName); break; }
        }

        for (Employee e : st.employees) {
            for (DutyAssign a : e.dutyAssignments) {
                if (a.sectionId.equalsIgnoreCase(secId) && a.dutyName.equalsIgnoreCase(oldName)) a.dutyName = newName;
            }
        }

        System.out.println("SUCCESS.");
    }

    static void deleteDutyFromSection(Scanner sc, Store st) {
        listSections(st);
        String secId = Input.readString(sc, "Section ID (blank cancels): ", true);
        if (secId == null) return;

        Section sec = st.findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }
        if (sec.dutyNames.isEmpty()) { System.out.println("ERROR: No duties to delete."); return; }

        System.out.println("Duties:");
        for (String d : sec.dutyNames) System.out.println(" - " + d);

        String duty = Input.readString(sc, "Duty Name to delete (exact) (blank cancels): ", true);
        if (duty == null) return;
        if (!st.sectionHasDuty(secId, duty)) { System.out.println("ERROR: Duty not found."); return; }

        sec.dutyNames.removeIf(d -> d.equalsIgnoreCase(duty));
        for (Employee e : st.employees) {
            e.dutyAssignments.removeIf(a -> a.sectionId.equalsIgnoreCase(secId) && a.dutyName.equalsIgnoreCase(duty));
        }

        System.out.println("SUCCESS.");
    }

    /* ============================================================
     * SHIFT SCHEDULES + TEAMS + APPLY/REMOVE
     * ============================================================
     * NOTE: For space, these are implemented in Store with menu hooks.
     */
    static void shiftSchedules(Scanner sc, Store st) { st.shiftSchedulesMenu(sc); }
    static void shiftTeams(Scanner sc, Store st) { st.shiftTeamsMenu(sc); }
    static void applyTeamSchedule(Scanner sc, Store st) { st.applyTeamScheduleMenu(sc); }
    static void removeTeamShifts(Scanner sc, Store st) { st.removeTeamShiftsMenu(sc); }

    static void listShiftTeams(Store st) { st.listShiftTeams(); }

    /* ============================================================
     * EVENTS / DRILL / VIEWS / REPORTS
     * ============================================================
     * Implemented in Store for code size control.
     */
    static void eventsMenu(Scanner sc, Store st) { st.eventsMenu(sc); }
    static void drillMenu(Scanner sc, Store st) { st.drillMenu(sc); }
    static void viewsMenu(Scanner sc, Store st) { st.viewsMenu(sc); }

    static void reportDutyCounts(Store st) { st.reportDutyCounts(); }
    static void reportDutiesByEmployee(Store st) { st.reportDutiesByEmployee(); }
    static void reportWhoHoldsDuty(Scanner sc, Store st) { st.reportWhoHoldsDuty(sc); }
    static void reportRaters(Store st) { st.reportRaters(); }
    static void availabilityDashboard(Scanner sc, Store st) { st.availabilityDashboard(sc); }
}

/* ============================================================
 * INPUT HELPERS
 * ============================================================
 */
class Input {
    static Integer readInt(Scanner sc, String prompt, boolean allowBlank) {
        while (true) {
            System.out.print(prompt);
            String line = sc.nextLine();
            if (line == null) line = "";
            line = line.trim();
            if (allowBlank && line.isEmpty()) return null;
            try { return Integer.parseInt(line); }
            catch (Exception ex) { System.out.println("ERROR: Enter a valid whole number."); }
        }
    }

    static String readString(Scanner sc, String prompt, boolean allowBlank) {
        System.out.print(prompt);
        String line = sc.nextLine();
        if (line == null) line = "";
        line = line.trim();
        if (allowBlank && line.isEmpty()) return null;
        return line;
    }

    static LocalDate readDate(Scanner sc, String prompt, boolean allowBlank) {
        DateTimeFormatter fmt = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        while (true) {
            System.out.print(prompt);
            String line = sc.nextLine();
            if (line == null) line = "";
            line = line.trim();
            if (allowBlank && line.isEmpty()) return null;
            try { return LocalDate.parse(line, fmt); }
            catch (Exception ex) { System.out.println("ERROR: Date must be yyyy-MM-dd."); }
        }
    }

    static LocalTime readTime(Scanner sc, String prompt, boolean allowBlank) {
        DateTimeFormatter fmt = DateTimeFormatter.ofPattern("HH:mm");
        while (true) {
            System.out.print(prompt);
            String line = sc.nextLine();
            if (line == null) line = "";
            line = line.trim();
            if (allowBlank && line.isEmpty()) return null;
            try { return LocalTime.parse(line, fmt); }
            catch (Exception ex) { System.out.println("ERROR: Time must be HH:mm (24-hour)."); }
        }
    }

    static <T extends Enum<T>> T readEnum(Scanner sc, String prompt, Class<T> enumClass, boolean allowBlank) {
        while (true) {
            System.out.print(prompt);
            String line = sc.nextLine();
            if (line == null) line = "";
            line = line.trim();
            if (allowBlank && line.isEmpty()) return null;
            try { return Enum.valueOf(enumClass, line.toUpperCase()); }
            catch (Exception ex) { System.out.println("ERROR: Invalid value. Options: " + Arrays.toString(enumClass.getEnumConstants())); }
        }
    }

    static Boolean readYesNo(Scanner sc, String prompt, boolean allowBlank) {
        while (true) {
            System.out.print(prompt);
            String line = sc.nextLine();
            if (line == null) line = "";
            line = line.trim();
            if (allowBlank && line.isEmpty()) return null;
            if (line.equalsIgnoreCase("y") || line.equalsIgnoreCase("yes")) return true;
            if (line.equalsIgnoreCase("n") || line.equalsIgnoreCase("no")) return false;
            System.out.println("ERROR: Enter Y or N.");
        }
    }
}

/* ============================================================
 * ENUMS
 * ============================================================
 */
enum EmploymentType { FULL_TIME, TRADITIONAL }

enum EventType {
    SHIFT,
    APPOINTMENT,
    TRAINING,
    TDY,
    TEMPORARY_DUTY,
    DEPLOYMENT,
    ORDERS,
    NIGHT_FLYING,
    LEAVE,
    IN_PROCESSING,
    OUT_PROCESSING,
    DRILL_DAY,
    ALT_DRILL_DAY,
    FEDERAL_HOLIDAY,
    OTHER
}

enum ScheduleType { WEEKLY, ROTATION }

/* ============================================================
 * ORGANIZATION CLASSES
 * ============================================================
 */
class Wing { String wingId; String name; Wing(String id, String name){ this.wingId=id; this.name=name; } }
class Group { String groupId; String name; String wingId=""; Group(String id,String name){ this.groupId=id; this.name=name; } }
class Squadron { String squadronId; String name; String groupId=""; Squadron(String id,String name){ this.squadronId=id; this.name=name; } }

class Section {
    String sectionId;
    String name;
    String squadronId="";
    ArrayList<String> dutyNames=new ArrayList<>();
    Section(String id,String name){ this.sectionId=id; this.name=name; }
}

/* ============================================================
 * EMPLOYEE + DUTY ASSIGNMENT
 * ============================================================
 */
class DutyAssign { String sectionId; String dutyName; DutyAssign(String s,String d){ sectionId=s; dutyName=d; } }

class Employee {
    String employeeId;
    String rank="";
    String firstName="";
    String lastName="";
    EmploymentType type=EmploymentType.FULL_TIME;
    int skillLevel=0;
    String raterEmployeeId="";
    String shiftTeamId="";
    ArrayList<String> sectionIds=new ArrayList<>();
    ArrayList<DutyAssign> dutyAssignments=new ArrayList<>();
    Employee(String id){ employeeId=id; }
}

/* ============================================================
 * SHIFT SCHEDULE + TEAM
 * ============================================================
 */
class ShiftSchedule {
    String scheduleId;
    String name;
    ScheduleType type=ScheduleType.WEEKLY;
    LocalTime startTime=LocalTime.of(6,0);
    LocalTime endTime=LocalTime.of(14,0);
    boolean[] weeklyMask=new boolean[]{true,true,true,true,true,false,false};
    int cycleLengthDays=6;
    int onDays=2;
    LocalDate anchorDate=LocalDate.now();
    boolean deployed=false;
    ShiftSchedule(String id,String name){ this.scheduleId=id; this.name=name; }
}

class ShiftTeam {
    String teamId;
    String name;
    String scheduleId="";
    int rotationOffsetDays=0;
    boolean deployed=false;
    ShiftTeam(String id,String name){ this.teamId=id; this.name=name; }
}

/* ============================================================
 * DRILL AVAILABILITY
 * ============================================================
 */
class DrillAvailability {
    String employeeId;
    LocalDate drillDate;
    boolean available;
    DrillAvailability(String empId, LocalDate d, boolean a){ employeeId=empId; drillDate=d; available=a; }
}

/* ============================================================
 * EVENT
 * ============================================================
 */
class Event {
    String eventId;
    EventType eventType=EventType.OTHER;
    String title="";
    String notes="";
    LocalDateTime startDateTime=LocalDateTime.now();
    LocalDateTime endDateTime=LocalDateTime.now().plusHours(1);
    String employeeIdOrNull="";
    Event(String id){ eventId=id; }
    boolean isGlobal(){ return employeeIdOrNull==null || employeeIdOrNull.trim().isEmpty(); }
}

/* ============================================================
 * STORE
 * ============================================================
 * Contains all data, scheduling rules, load/save, and large menus.
 */
class Store {

    // ============================================================
    // DATA LISTS
    // ============================================================
    ArrayList<Wing> wings = new ArrayList<>();
    ArrayList<Group> groups = new ArrayList<>();
    ArrayList<Squadron> squadrons = new ArrayList<>();
    ArrayList<Section> sections = new ArrayList<>();
    ArrayList<Employee> employees = new ArrayList<>();

    ArrayList<ShiftSchedule> shiftSchedules = new ArrayList<>();
    ArrayList<ShiftTeam> shiftTeams = new ArrayList<>();

    ArrayList<Event> events = new ArrayList<>();
    ArrayList<DrillAvailability> drillAvailabilityList = new ArrayList<>();

    // ============================================================
    // FILE NAMES
    // ============================================================
    final String WINGS = "wings.csv";
    final String GROUPS = "groups.csv";
    final String SQUADS = "squadrons.csv";
    final String SECTS = "sections.csv";
    final String EMPS = "employees.csv";
    final String SCHEDULES = "shift_schedules.csv";
    final String TEAMS = "shift_teams.csv";
    final String EVENTS = "events.csv";
    final String DRILL_AVAIL = "drill_availability.csv";

    // ============================================================
    // FORMATTERS
    // ============================================================
    final DateTimeFormatter DATE_FMT = DateTimeFormatter.ofPattern("yyyy-MM-dd");
    final DateTimeFormatter TIME_FMT = DateTimeFormatter.ofPattern("HH:mm");
    final DateTimeFormatter DT_FMT = DateTimeFormatter.ISO_LOCAL_DATE_TIME;

    // ============================================================
    // ID COUNTERS
    // ============================================================
    int nextEventNum = 1;
    int nextScheduleNum = 1;
    int nextTeamNum = 1;

    // ============================================================
    // FIND HELPERS
    // ============================================================
    Wing findWing(String id) { for (Wing w : wings) if (w.wingId.equalsIgnoreCase(id)) return w; return null; }
    Group findGroup(String id) { for (Group g : groups) if (g.groupId.equalsIgnoreCase(id)) return g; return null; }
    Squadron findSquadron(String id) { for (Squadron s : squadrons) if (s.squadronId.equalsIgnoreCase(id)) return s; return null; }
    Section findSection(String id) { for (Section s : sections) if (s.sectionId.equalsIgnoreCase(id)) return s; return null; }
    Employee findEmployee(String id) { for (Employee e : employees) if (e.employeeId.equalsIgnoreCase(id)) return e; return null; }

    ShiftSchedule findShiftSchedule(String id) { for (ShiftSchedule s : shiftSchedules) if (s.scheduleId.equalsIgnoreCase(id)) return s; return null; }
    ShiftTeam findShiftTeam(String id) { for (ShiftTeam t : shiftTeams) if (t.teamId.equalsIgnoreCase(id)) return t; return null; }
    Event findEvent(String id) { for (Event e : events) if (e.eventId.equalsIgnoreCase(id)) return e; return null; }

    boolean containsIgnoreCase(List<String> list, String value) {
        for (String s : list) if (s.equalsIgnoreCase(value)) return true;
        return false;
    }

    boolean sectionHasDuty(String sectionId, String dutyName) {
        Section sec = findSection(sectionId);
        if (sec == null) return false;
        for (String d : sec.dutyNames) if (d.equalsIgnoreCase(dutyName)) return true;
        return false;
    }

    boolean employeeHasDuty(Employee e, String sectionId, String dutyName) {
        for (DutyAssign a : e.dutyAssignments) {
            if (a.sectionId.equalsIgnoreCase(sectionId) && a.dutyName.equalsIgnoreCase(dutyName)) return true;
        }
        return false;
    }

    // ============================================================
    // SECTION CHAIN DISPLAY
    // ============================================================
    String formatSectionChain(String sectionId) {
        Section sec = findSection(sectionId);
        if (sec == null) return sectionId + " (missing section record)";

        String squadPart = "UNASSIGNED";
        String groupPart = "UNASSIGNED";
        String wingPart = "UNASSIGNED";

        if (!sec.squadronId.isEmpty()) {
            Squadron sq = findSquadron(sec.squadronId);
            if (sq != null) {
                squadPart = sq.squadronId + " " + sq.name;

                if (!sq.groupId.isEmpty()) {
                    Group g = findGroup(sq.groupId);
                    if (g != null) {
                        groupPart = g.groupId + " " + g.name;

                        if (!g.wingId.isEmpty()) {
                            Wing w = findWing(g.wingId);
                            if (w != null) wingPart = w.wingId + " " + w.name;
                        }
                    }
                }
            }
        }

        return sec.sectionId + " " + sec.name + " | Sq: " + squadPart + " | Gp: " + groupPart + " | Wg: " + wingPart;
    }

    // ============================================================
    // LOAD/SAVE ENTRY POINTS
    // ============================================================
    void loadAll() {
        ensureFileExists(WINGS);
        ensureFileExists(GROUPS);
        ensureFileExists(SQUADS);
        ensureFileExists(SECTS);
        ensureFileExists(EMPS);
        ensureFileExists(SCHEDULES);
        ensureFileExists(TEAMS);
        ensureFileExists(EVENTS);
        ensureFileExists(DRILL_AVAIL);

        loadWings();
        loadGroups();
        loadSquads();
        loadSects();
        loadEmps();
        loadSchedules();
        loadTeams();
        loadEvents();
        loadDrillAvailability();

        rebuildCounters();

        int y = LocalDate.now().getYear();
        ensureFederalHolidaysForYear(y);
        ensureFederalHolidaysForYear(y + 1);

        rebuildCounters();
    }

    void saveAll() {
        saveWings();
        saveGroups();
        saveSquads();
        saveSects();
        saveEmps();
        saveSchedules();
        saveTeams();
        saveEvents();
        saveDrillAvailability();
    }

    // ============================================================
    // FILE CREATION
    // ============================================================
    void ensureFileExists(String filename) {
        File f = new File(filename);
        if (f.exists()) return;
        try (FileWriter fw = new FileWriter(filename, true)) { } catch (Exception ex) { }
    }

    // ============================================================
    // CSV CLEANING
    // ============================================================
    static String cleanField(String s) {
        if (s == null) return "";
        String t = s.trim();
        t = t.replace("\n", " ").replace("\r", " ");
        t = t.replace(",", " ");
        t = t.replace("|", "/");
        t = t.replace(":", "/");
        return t;
    }

    static String joinPipe(List<String> list) {
        if (list == null || list.isEmpty()) return "";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < list.size(); i++) {
            sb.append(cleanField(list.get(i)));
            if (i < list.size() - 1) sb.append("|");
        }
        return sb.toString();
    }

    static ArrayList<String> splitPipe(String s) {
        ArrayList<String> out = new ArrayList<>();
        if (s == null) return out;
        String t = s.trim();
        if (t.isEmpty()) return out;

        String[] parts = t.split("\\|", -1);
        for (String p : parts) {
            String v = p.trim();
            if (!v.isEmpty()) out.add(v);
        }
        return out;
    }

    static String encodeDutyAssign(List<DutyAssign> list) {
        if (list == null || list.isEmpty()) return "";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < list.size(); i++) {
            DutyAssign a = list.get(i);
            sb.append(cleanField(a.sectionId)).append(":").append(cleanField(a.dutyName));
            if (i < list.size() - 1) sb.append("|");
        }
        return sb.toString();
    }

    static ArrayList<DutyAssign> decodeDutyAssign(String s) {
        ArrayList<DutyAssign> out = new ArrayList<>();
        if (s == null) return out;
        String t = s.trim();
        if (t.isEmpty()) return out;

        String[] parts = t.split("\\|", -1);
        for (String item : parts) {
            String x = item.trim();
            if (x.isEmpty()) continue;

            String[] kv = x.split(":", -1);
            if (kv.length >= 2) {
                String secId = kv[0].trim();
                String duty = kv[1].trim();
                if (!secId.isEmpty() && !duty.isEmpty()) out.add(new DutyAssign(secId, duty));
            }
        }
        return out;
    }

    static String encodeWeeklyMask(boolean[] mask) {
        if (mask == null || mask.length != 7) return "";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 7; i++) sb.append(mask[i] ? "1" : "0");
        return sb.toString();
    }

    static boolean[] decodeWeeklyMask(String s) {
        boolean[] mask = new boolean[7];
        if (s == null) return mask;
        String t = s.trim();
        if (t.length() < 7) return mask;
        for (int i = 0; i < 7; i++) mask[i] = (t.charAt(i) == '1');
        return mask;
    }

    // ============================================================
    // CSV READ/WRITE
    // ============================================================
    ArrayList<String[]> readCsv(String file) {
        ArrayList<String[]> rows = new ArrayList<>();
        try (BufferedReader br = new BufferedReader(new FileReader(file))) {
            String line;
            while ((line = br.readLine()) != null) {
                String[] p = line.split(",", -1);
                for (int i = 0; i < p.length; i++) p[i] = p[i].trim();
                rows.add(p);
            }
        } catch (Exception ex) { }
        return rows;
    }

    void writeCsv(String file, ArrayList<String[]> rows) {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(file))) {
            for (String[] r : rows) {
                for (int i = 0; i < r.length; i++) {
                    bw.write(cleanField(r[i]));
                    if (i < r.length - 1) bw.write(",");
                }
                bw.newLine();
            }
        } catch (Exception ex) {
            System.out.println("ERROR: Could not save " + file);
        }
    }

    // ============================================================
    // LOADERS
    // ============================================================
    void loadWings() {
        wings.clear();
        for (String[] p : readCsv(WINGS)) if (p.length >= 2) wings.add(new Wing(p[0], p[1]));
    }

    void loadGroups() {
        groups.clear();
        for (String[] p : readCsv(GROUPS)) {
            if (p.length >= 2) {
                Group g = new Group(p[0], p[1]);
                if (p.length >= 3) g.wingId = p[2];
                groups.add(g);
            }
        }
    }

    void loadSquads() {
        squadrons.clear();
        for (String[] p : readCsv(SQUADS)) {
            if (p.length >= 2) {
                Squadron s = new Squadron(p[0], p[1]);
                if (p.length >= 3) s.groupId = p[2];
                squadrons.add(s);
            }
        }
    }

    void loadSects() {
        sections.clear();
        for (String[] p : readCsv(SECTS)) {
            if (p.length >= 2) {
                Section s = new Section(p[0], p[1]);
                if (p.length >= 3) s.squadronId = p[2];
                if (p.length >= 4) s.dutyNames = splitPipe(p[3]);
                sections.add(s);
            }
        }
    }

    void loadEmps() {
        employees.clear();
        for (String[] p : readCsv(EMPS)) {
            if (p.length >= 6) {
                Employee e = new Employee(p[0]);
                e.rank = p[1];
                e.firstName = p[2];
                e.lastName = p[3];

                try { e.type = EmploymentType.valueOf(p[4]); }
                catch (Exception ex) { e.type = EmploymentType.FULL_TIME; }

                try { e.skillLevel = Integer.parseInt(p[5]); }
                catch (Exception ex) { e.skillLevel = 0; }

                if (p.length >= 7) e.raterEmployeeId = p[6];
                if (p.length >= 8) e.sectionIds = splitPipe(p[7]);
                if (p.length >= 9) e.dutyAssignments = decodeDutyAssign(p[8]);
                if (p.length >= 10) e.shiftTeamId = p[9];

                employees.add(e);
            }
        }
    }

    void loadSchedules() {
        shiftSchedules.clear();
        for (String[] p : readCsv(SCHEDULES)) {
            if (p.length >= 10) {
                ShiftSchedule s = new ShiftSchedule(p[0], p[1]);
                try { s.type = ScheduleType.valueOf(p[2]); } catch (Exception ex) { s.type = ScheduleType.WEEKLY; }
                try { s.startTime = LocalTime.parse(p[3], TIME_FMT); } catch (Exception ex) { }
                try { s.endTime = LocalTime.parse(p[4], TIME_FMT); } catch (Exception ex) { }
                s.weeklyMask = decodeWeeklyMask(p[5]);
                try { s.cycleLengthDays = Integer.parseInt(p[6]); } catch (Exception ex) { }
                try { s.onDays = Integer.parseInt(p[7]); } catch (Exception ex) { }
                try { s.anchorDate = LocalDate.parse(p[8], DATE_FMT); } catch (Exception ex) { }
                try { s.deployed = Boolean.parseBoolean(p[9]); } catch (Exception ex) { }
                shiftSchedules.add(s);
            }
        }
    }

    void loadTeams() {
        shiftTeams.clear();
        for (String[] p : readCsv(TEAMS)) {
            if (p.length >= 5) {
                ShiftTeam t = new ShiftTeam(p[0], p[1]);
                t.scheduleId = p[2];
                try { t.rotationOffsetDays = Integer.parseInt(p[3]); } catch (Exception ex) { }
                try { t.deployed = Boolean.parseBoolean(p[4]); } catch (Exception ex) { }
                shiftTeams.add(t);
            }
        }
    }

    void loadEvents() {
        events.clear();
        for (String[] p : readCsv(EVENTS)) {
            if (p.length >= 7) {
                Event ev = new Event(p[0]);
                try { ev.eventType = EventType.valueOf(p[1]); } catch (Exception ex) { ev.eventType = EventType.OTHER; }
                ev.title = p[2];
                ev.notes = p[3];
                try { ev.startDateTime = LocalDateTime.parse(p[4], DT_FMT); } catch (Exception ex) { continue; }
                try { ev.endDateTime = LocalDateTime.parse(p[5], DT_FMT); } catch (Exception ex) { continue; }
                ev.employeeIdOrNull = p[6];
                events.add(ev);
            }
        }
    }

    void loadDrillAvailability() {
        drillAvailabilityList.clear();
        for (String[] p : readCsv(DRILL_AVAIL)) {
            if (p.length >= 3) {
                try {
                    drillAvailabilityList.add(
                            new DrillAvailability(p[0], LocalDate.parse(p[1], DATE_FMT), Boolean.parseBoolean(p[2]))
                    );
                } catch (Exception ex) { }
            }
        }
    }

    // ============================================================
    // SAVERS
    // ============================================================
    void saveWings() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (Wing w : wings) rows.add(new String[]{w.wingId, w.name});
        writeCsv(WINGS, rows);
    }

    void saveGroups() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (Group g : groups) rows.add(new String[]{g.groupId, g.name, g.wingId});
        writeCsv(GROUPS, rows);
    }

    void saveSquads() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (Squadron s : squadrons) rows.add(new String[]{s.squadronId, s.name, s.groupId});
        writeCsv(SQUADS, rows);
    }

    void saveSects() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (Section s : sections) rows.add(new String[]{s.sectionId, s.name, s.squadronId, joinPipe(s.dutyNames)});
        writeCsv(SECTS, rows);
    }

    void saveEmps() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (Employee e : employees) {
            rows.add(new String[]{
                    e.employeeId,
                    e.rank,
                    e.firstName,
                    e.lastName,
                    e.type.toString(),
                    String.valueOf(e.skillLevel),
                    e.raterEmployeeId,
                    joinPipe(e.sectionIds),
                    encodeDutyAssign(e.dutyAssignments),
                    e.shiftTeamId
            });
        }
        writeCsv(EMPS, rows);
    }

    void saveSchedules() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (ShiftSchedule s : shiftSchedules) {
            rows.add(new String[]{
                    s.scheduleId,
                    s.name,
                    s.type.toString(),
                    s.startTime.format(TIME_FMT),
                    s.endTime.format(TIME_FMT),
                    encodeWeeklyMask(s.weeklyMask),
                    String.valueOf(s.cycleLengthDays),
                    String.valueOf(s.onDays),
                    s.anchorDate.format(DATE_FMT),
                    String.valueOf(s.deployed)
            });
        }
        writeCsv(SCHEDULES, rows);
    }

    void saveTeams() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (ShiftTeam t : shiftTeams) {
            rows.add(new String[]{
                    t.teamId,
                    t.name,
                    t.scheduleId,
                    String.valueOf(t.rotationOffsetDays),
                    String.valueOf(t.deployed)
            });
        }
        writeCsv(TEAMS, rows);
    }

    void saveEvents() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (Event e : events) {
            rows.add(new String[]{
                    e.eventId,
                    e.eventType.toString(),
                    e.title,
                    e.notes,
                    e.startDateTime.format(DT_FMT),
                    e.endDateTime.format(DT_FMT),
                    e.employeeIdOrNull
            });
        }
        writeCsv(EVENTS, rows);
    }

    void saveDrillAvailability() {
        ArrayList<String[]> rows = new ArrayList<>();
        for (DrillAvailability da : drillAvailabilityList) {
            rows.add(new String[]{da.employeeId, da.drillDate.format(DATE_FMT), String.valueOf(da.available)});
        }
        writeCsv(DRILL_AVAIL, rows);
    }

    // ============================================================
    // ID GENERATION
    // ============================================================
    void rebuildCounters() {
        nextEventNum = 1;
        nextScheduleNum = 1;
        nextTeamNum = 1;

        for (Event e : events) nextEventNum = Math.max(nextEventNum, extractNumeric(e.eventId) + 1);
        for (ShiftSchedule s : shiftSchedules) nextScheduleNum = Math.max(nextScheduleNum, extractNumeric(s.scheduleId) + 1);
        for (ShiftTeam t : shiftTeams) nextTeamNum = Math.max(nextTeamNum, extractNumeric(t.teamId) + 1);
    }

    int extractNumeric(String id) {
        if (id == null) return 0;
        String digits = id.replaceAll("[^0-9]", "");
        if (digits.isEmpty()) return 0;
        try { return Integer.parseInt(digits); } catch (Exception ex) { return 0; }
    }

    String nextEventId() { return String.format("EV%05d", nextEventNum++); }
    String nextScheduleId() { return String.format("SCH%04d", nextScheduleNum++); }
    String nextTeamId() { return String.format("T%04d", nextTeamNum++); }

    // ============================================================
    // SHIFT WINDOW TYPE
    // ============================================================
    static class ShiftWindow {
        LocalDateTime start;
        LocalDateTime end;
        ShiftWindow(LocalDateTime s, LocalDateTime e) { start = s; end = e; }
    }

    // ============================================================
    // EVENT TIME HELPERS
    // ============================================================
    boolean overlaps(LocalDateTime aStart, LocalDateTime aEnd, LocalDateTime bStart, LocalDateTime bEnd) {
        return aStart.isBefore(bEnd) && bStart.isBefore(aEnd);
    }

    LocalDateTime dayStart(LocalDate d) { return d.atStartOfDay(); }
    LocalDateTime dayEnd(LocalDate d) { return d.plusDays(1).atStartOfDay(); }

    // ============================================================
    // EMPLOYEE EFFECTIVE STATUS (TRADITIONAL ON ORDERS)
    // ============================================================
    boolean isTraditionalOnOrders(Employee e, LocalDate date) {
        if (e == null) return false;
        if (e.type != EmploymentType.TRADITIONAL) return false;

        LocalDateTime s = dayStart(date);
        LocalDateTime en = dayEnd(date);

        for (Event ev : events) {
            if (ev.eventType != EventType.ORDERS) continue;
            if (ev.employeeIdOrNull == null) continue;
            if (!ev.employeeIdOrNull.equalsIgnoreCase(e.employeeId)) continue;
            if (overlaps(ev.startDateTime, ev.endDateTime, s, en)) return true;
        }
        return false;
    }

    // ============================================================
    // SHIFT WINDOW CALCULATION (EXPECTED SHIFT)
    // ============================================================
    ShiftWindow expectedShiftWindow(Employee e, LocalDate date) {
        if (e == null) return null;
        if (e.shiftTeamId == null || e.shiftTeamId.trim().isEmpty()) return null;

        ShiftTeam team = findShiftTeam(e.shiftTeamId);
        if (team == null) return null;

        ShiftSchedule sched = findShiftSchedule(team.scheduleId);
        if (sched == null) return null;

        boolean works = false;

        if (sched.type == ScheduleType.WEEKLY) {
            int idx = date.getDayOfWeek().getValue() - 1; // Mon=0
            if (idx >= 0 && idx < 7) works = sched.weeklyMask[idx];
        } else {
            long delta = ChronoUnit.DAYS.between(sched.anchorDate, date);
            int cycle = Math.max(1, sched.cycleLengthDays);
            int dayIndex = (int)((delta + team.rotationOffsetDays) % cycle);
            if (dayIndex < 0) dayIndex += cycle;
            works = (dayIndex < Math.max(0, sched.onDays));
        }

        if (!works) return null;

        LocalDateTime start = LocalDateTime.of(date, sched.startTime);
        LocalDateTime end;

        if (sched.endTime.equals(sched.startTime)) {
            end = start.plusHours(8);
        } else if (sched.endTime.isAfter(sched.startTime)) {
            end = LocalDateTime.of(date, sched.endTime);
        } else {
            end = LocalDateTime.of(date.plusDays(1), sched.endTime);
        }

        return new ShiftWindow(start, end);
    }

    // ============================================================
    // NON-SHIFT CONFLICT CHECK (SHIFT IS BASELINE AND DOES NOT CONFLICT)
    // ============================================================
    ArrayList<Event> findNonShiftConflicts(String employeeId, LocalDateTime start, LocalDateTime end, String excludeEventId) {
        ArrayList<Event> out = new ArrayList<>();
        if (employeeId == null || employeeId.trim().isEmpty()) return out;

        for (Event ev : events) {
            if (excludeEventId != null && ev.eventId.equalsIgnoreCase(excludeEventId)) continue;
            if (ev.employeeIdOrNull == null || ev.employeeIdOrNull.trim().isEmpty()) continue;
            if (!ev.employeeIdOrNull.equalsIgnoreCase(employeeId)) continue;

            if (ev.eventType == EventType.SHIFT) continue;
            if (!overlaps(ev.startDateTime, ev.endDateTime, start, end)) continue;

            out.add(ev);
        }
        return out;
    }

    // ============================================================
    // GLOBAL EVENT FINDERS
    // ============================================================
    ArrayList<Event> globalEventsOnDate(LocalDate d) {
        ArrayList<Event> out = new ArrayList<>();
        LocalDateTime s = dayStart(d);
        LocalDateTime e = dayEnd(d);

        for (Event ev : events) {
            if (!ev.isGlobal()) continue;
            if (overlaps(ev.startDateTime, ev.endDateTime, s, e)) out.add(ev);
        }
        out.sort(Comparator.comparing(a -> a.startDateTime));
        return out;
    }

    ArrayList<Event> employeeEventsOnDate(String empId, LocalDate d) {
        ArrayList<Event> out = new ArrayList<>();
        LocalDateTime s = dayStart(d);
        LocalDateTime e = dayEnd(d);

        for (Event ev : events) {
            if (ev.employeeIdOrNull == null || ev.employeeIdOrNull.trim().isEmpty()) continue;
            if (!ev.employeeIdOrNull.equalsIgnoreCase(empId)) continue;
            if (overlaps(ev.startDateTime, ev.endDateTime, s, e)) out.add(ev);
        }
        out.sort(Comparator.comparing(a -> a.startDateTime));
        return out;
    }

    // ============================================================
    // SHIFT EVENT HELPERS
    // ============================================================
    String shiftTitleForTeam(String teamId) { return "SHIFT " + teamId; }

    boolean hasShiftEventOnDate(String empId, LocalDate d) {
        LocalDateTime s = dayStart(d);
        LocalDateTime e = dayEnd(d);
        for (Event ev : events) {
            if (ev.eventType != EventType.SHIFT) continue;
            if (ev.employeeIdOrNull == null || ev.employeeIdOrNull.trim().isEmpty()) continue;
            if (!ev.employeeIdOrNull.equalsIgnoreCase(empId)) continue;
            if (overlaps(ev.startDateTime, ev.endDateTime, s, e)) return true;
        }
        return false;
    }

    // ============================================================
    // ============================================================
    // SHIFT SCHEDULES MENU
    // ============================================================
    // ============================================================
    void shiftSchedulesMenu(Scanner sc) {
        while (true) {
            System.out.println("\n--- SHIFT SCHEDULES ---");
            System.out.println("1) List Schedules");
            System.out.println("2) Create Schedule");
            System.out.println("3) Edit Schedule");
            System.out.println("4) Delete Schedule");
            System.out.println("5) Back");

            Integer c = Input.readInt(sc, "Choice: ", true);
            if (c == null) continue;

            if (c == 1) listSchedules();
            else if (c == 2) createSchedule(sc);
            else if (c == 3) editSchedule(sc);
            else if (c == 4) deleteSchedule(sc);
            else if (c == 5) return;
            else System.out.println("ERROR: Invalid choice.");
        }
    }

    void listSchedules() {
        System.out.println("\nSCHEDULES");
        if (shiftSchedules.isEmpty()) { System.out.println("(None)"); return; }
        for (ShiftSchedule s : shiftSchedules) {
            String type = s.type.toString();
            String time = s.startTime.format(TIME_FMT) + "-" + s.endTime.format(TIME_FMT);
            if (s.type == ScheduleType.WEEKLY) {
                System.out.println(s.scheduleId + " | " + s.name + " | " + type + " | " + time +
                        " | Mask(M..Su): " + encodeWeeklyMask(s.weeklyMask) +
                        (s.deployed ? " | DEPLOYED" : ""));
            } else {
                System.out.println(s.scheduleId + " | " + s.name + " | " + type + " | " + time +
                        " | Cycle=" + s.cycleLengthDays + " On=" + s.onDays +
                        " | Anchor=" + s.anchorDate.format(DATE_FMT) +
                        (s.deployed ? " | DEPLOYED" : ""));
            }
        }
    }

    boolean[] readWeeklyMask(Scanner sc) {
        while (true) {
            String mask = Input.readString(sc, "Workdays mask Mon..Sun (example 1111000) (blank cancels): ", true);
            if (mask == null) return null;
            mask = mask.trim();
            if (mask.length() != 7) {
                System.out.println("ERROR: Must be exactly 7 digits (Mon..Sun).");
                continue;
            }
            boolean ok = true;
            for (char ch : mask.toCharArray()) if (ch != '0' && ch != '1') ok = false;
            if (!ok) {
                System.out.println("ERROR: Use only 0 or 1.");
                continue;
            }
            return decodeWeeklyMask(mask);
        }
    }

    void createSchedule(Scanner sc) {
        String name = Input.readString(sc, "Schedule Name (blank cancels): ", true);
        if (name == null) return;

        ScheduleType type = Input.readEnum(sc, "Schedule Type (WEEKLY/ROTATION) (blank cancels): ", ScheduleType.class, true);
        if (type == null) return;

        LocalTime start = Input.readTime(sc, "Start Time HH:mm (blank cancels): ", true);
        if (start == null) return;

        LocalTime end = Input.readTime(sc, "End Time HH:mm (blank cancels): ", true);
        if (end == null) return;

        Boolean deployed = Input.readYesNo(sc, "Deployed? (Y/N) (blank cancels): ", true);
        if (deployed == null) return;

        ShiftSchedule s = new ShiftSchedule(nextScheduleId(), name);
        s.type = type;
        s.startTime = start;
        s.endTime = end;
        s.deployed = deployed;

        if (type == ScheduleType.WEEKLY) {
            boolean[] mask = readWeeklyMask(sc);
            if (mask == null) return;
            s.weeklyMask = mask;
        } else {
            LocalDate anchor = Input.readDate(sc, "Anchor Date yyyy-MM-dd (blank cancels): ", true);
            if (anchor == null) return;

            Integer cycle = Input.readInt(sc, "Cycle length days (example 6) (blank cancels): ", true);
            if (cycle == null) return;

            Integer onDays = Input.readInt(sc, "On days per cycle (example 2) (blank cancels): ", true);
            if (onDays == null) return;

            s.anchorDate = anchor;
            s.cycleLengthDays = Math.max(1, cycle);
            s.onDays = Math.max(0, Math.min(s.cycleLengthDays, onDays));
        }

        shiftSchedules.add(s);
        System.out.println("SUCCESS: Created " + s.scheduleId);
    }

    void editSchedule(Scanner sc) {
        listSchedules();
        String id = Input.readString(sc, "Schedule ID (blank cancels): ", true);
        if (id == null) return;

        ShiftSchedule s = findShiftSchedule(id);
        if (s == null) { System.out.println("ERROR: Not found."); return; }

        while (true) {
            System.out.println("\nEdit Schedule: " + s.scheduleId + " | " + s.name);
            System.out.println("1) Name");
            System.out.println("2) Type");
            System.out.println("3) Start Time");
            System.out.println("4) End Time");
            System.out.println("5) Weekly Mask (if WEEKLY)");
            System.out.println("6) Rotation Settings (if ROTATION)");
            System.out.println("7) Deployed Flag");
            System.out.println("8) Back");

            Integer c = Input.readInt(sc, "Choice: ", true);
            if (c == null) continue;

            if (c == 1) {
                String v = Input.readString(sc, "New Name (blank cancels): ", true);
                if (v != null) s.name = v;
            } else if (c == 2) {
                ScheduleType t = Input.readEnum(sc, "Schedule Type (WEEKLY/ROTATION) (blank cancels): ", ScheduleType.class, true);
                if (t != null) s.type = t;
            } else if (c == 3) {
                LocalTime v = Input.readTime(sc, "New Start Time HH:mm (blank cancels): ", true);
                if (v != null) s.startTime = v;
            } else if (c == 4) {
                LocalTime v = Input.readTime(sc, "New End Time HH:mm (blank cancels): ", true);
                if (v != null) s.endTime = v;
            } else if (c == 5) {
                if (s.type != ScheduleType.WEEKLY) { System.out.println("ERROR: Not a WEEKLY schedule."); continue; }
                boolean[] v = readWeeklyMask(sc);
                if (v != null) s.weeklyMask = v;
            } else if (c == 6) {
                if (s.type != ScheduleType.ROTATION) { System.out.println("ERROR: Not a ROTATION schedule."); continue; }
                LocalDate anchor = Input.readDate(sc, "New Anchor Date yyyy-MM-dd (blank cancels): ", true);
                if (anchor == null) continue;

                Integer cycle = Input.readInt(sc, "New Cycle length days (blank cancels): ", true);
                if (cycle == null) continue;

                Integer onDays = Input.readInt(sc, "New On days per cycle (blank cancels): ", true);
                if (onDays == null) continue;

                s.anchorDate = anchor;
                s.cycleLengthDays = Math.max(1, cycle);
                s.onDays = Math.max(0, Math.min(s.cycleLengthDays, onDays));
            } else if (c == 7) {
                Boolean v = Input.readYesNo(sc, "Deployed? (Y/N) (blank cancels): ", true);
                if (v != null) s.deployed = v;
            } else if (c == 8) {
                return;
            } else {
                System.out.println("ERROR: Invalid choice.");
            }
        }
    }

    void deleteSchedule(Scanner sc) {
        listSchedules();
        String id = Input.readString(sc, "Schedule ID (blank cancels): ", true);
        if (id == null) return;

        ShiftSchedule s = findShiftSchedule(id);
        if (s == null) { System.out.println("ERROR: Not found."); return; }

        for (ShiftTeam t : shiftTeams) {
            if (t.scheduleId.equalsIgnoreCase(id)) t.scheduleId = "";
        }

        shiftSchedules.remove(s);
        System.out.println("SUCCESS: Deleted. Teams referencing it were unassigned.");
    }

    // ============================================================
    // ============================================================
    // SHIFT TEAMS MENU
    // ============================================================
    // ============================================================
    void shiftTeamsMenu(Scanner sc) {
        while (true) {
            System.out.println("\n--- SHIFT TEAMS ---");
            System.out.println("1) List Teams");
            System.out.println("2) Create Team");
            System.out.println("3) Edit Team");
            System.out.println("4) Delete Team");
            System.out.println("5) Back");

            Integer c = Input.readInt(sc, "Choice: ", true);
            if (c == null) continue;

            if (c == 1) listShiftTeams();
            else if (c == 2) createTeam(sc);
            else if (c == 3) editTeam(sc);
            else if (c == 4) deleteTeam(sc);
            else if (c == 5) return;
            else System.out.println("ERROR: Invalid choice.");
        }
    }

    void listShiftTeams() {
        System.out.println("\nSHIFT TEAMS");
        if (shiftTeams.isEmpty()) { System.out.println("(None)"); return; }
        for (ShiftTeam t : shiftTeams) {
            String sched = t.scheduleId.isEmpty() ? "UNASSIGNED" : t.scheduleId;
            ShiftSchedule s = findShiftSchedule(t.scheduleId);
            String schedName = (s == null ? "" : " (" + s.name + ")");
            System.out.println(t.teamId + " | " + t.name + " | Schedule: " + sched + schedName +
                    " | Offset=" + t.rotationOffsetDays + (t.deployed ? " | DEPLOYED" : ""));
        }
    }

    void createTeam(Scanner sc) {
        String name = Input.readString(sc, "Team Name (blank cancels): ", true);
        if (name == null) return;

        listSchedules();
        String schedId = Input.readString(sc, "Schedule ID (blank cancels): ", true);
        if (schedId == null) return;

        if (!schedId.isEmpty() && findShiftSchedule(schedId) == null) {
            System.out.println("ERROR: Schedule not found.");
            return;
        }

        Integer offset = Input.readInt(sc, "Rotation Offset Days (0 for most weekly schedules) (blank cancels): ", true);
        if (offset == null) return;

        Boolean deployed = Input.readYesNo(sc, "Deployed team? (Y/N) (blank cancels): ", true);
        if (deployed == null) return;

        ShiftTeam t = new ShiftTeam(nextTeamId(), name);
        t.scheduleId = schedId;
        t.rotationOffsetDays = offset;
        t.deployed = deployed;

        shiftTeams.add(t);
        System.out.println("SUCCESS: Created " + t.teamId);
    }

    void editTeam(Scanner sc) {
        listShiftTeams();
        String id = Input.readString(sc, "Team ID (blank cancels): ", true);
        if (id == null) return;

        ShiftTeam t = findShiftTeam(id);
        if (t == null) { System.out.println("ERROR: Not found."); return; }

        while (true) {
            System.out.println("\nEdit Team: " + t.teamId + " | " + t.name);
            System.out.println("1) Name");
            System.out.println("2) Schedule ID");
            System.out.println("3) Rotation Offset");
            System.out.println("4) Deployed Flag");
            System.out.println("5) Back");

            Integer c = Input.readInt(sc, "Choice: ", true);
            if (c == null) continue;

            if (c == 1) {
                String v = Input.readString(sc, "New Name (blank cancels): ", true);
                if (v != null) t.name = v;
            } else if (c == 2) {
                listSchedules();
                String v = Input.readString(sc, "New Schedule ID (blank to clear): ", true);
                if (v == null) continue;
                if (v.isEmpty()) { t.scheduleId = ""; continue; }
                if (findShiftSchedule(v) == null) { System.out.println("ERROR: Schedule not found."); continue; }
                t.scheduleId = v;
            } else if (c == 3) {
                Integer v = Input.readInt(sc, "New Rotation Offset Days (blank cancels): ", true);
                if (v != null) t.rotationOffsetDays = v;
            } else if (c == 4) {
                Boolean v = Input.readYesNo(sc, "Deployed? (Y/N) (blank cancels): ", true);
                if (v != null) t.deployed = v;
            } else if (c == 5) {
                return;
            } else {
                System.out.println("ERROR: Invalid choice.");
            }
        }
    }

    void deleteTeam(Scanner sc) {
        listShiftTeams();
        String id = Input.readString(sc, "Team ID (blank cancels): ", true);
        if (id == null) return;

        ShiftTeam t = findShiftTeam(id);
        if (t == null) { System.out.println("ERROR: Not found."); return; }

        for (Employee e : employees) {
            if (e.shiftTeamId != null && e.shiftTeamId.equalsIgnoreCase(id)) e.shiftTeamId = "";
        }

        events.removeIf(ev -> ev.eventType == EventType.SHIFT && shiftTitleForTeam(id).equalsIgnoreCase(ev.title));

        shiftTeams.remove(t);
        System.out.println("SUCCESS: Deleted. Employees unassigned. Team shifts removed.");
    }

    // ============================================================
    // ============================================================
    // APPLY TEAM SCHEDULE (GENERATE SHIFT EVENTS)
    // ============================================================
    // ============================================================
    void applyTeamScheduleMenu(Scanner sc) {
        listShiftTeams();
        String teamId = Input.readString(sc, "Team ID (blank cancels): ", true);
        if (teamId == null) return;

        ShiftTeam team = findShiftTeam(teamId);
        if (team == null) { System.out.println("ERROR: Team not found."); return; }

        if (team.scheduleId == null || team.scheduleId.trim().isEmpty()) {
            System.out.println("ERROR: Team has no schedule assigned.");
            return;
        }

        ShiftSchedule sched = findShiftSchedule(team.scheduleId);
        if (sched == null) { System.out.println("ERROR: Schedule not found."); return; }

        LocalDate start = Input.readDate(sc, "Start Date yyyy-MM-dd (blank cancels): ", true);
        if (start == null) return;

        LocalDate end = Input.readDate(sc, "End Date yyyy-MM-dd (blank cancels): ", true);
        if (end == null) return;

        if (end.isBefore(start)) { System.out.println("ERROR: End date before start date."); return; }

        String shiftTitle = shiftTitleForTeam(team.teamId);

        // Remove existing SHIFT events for this team in the range (so re-generating doesn't duplicate)
        LocalDateTime rangeStart = dayStart(start);
        LocalDateTime rangeEnd = dayEnd(end);

        events.removeIf(ev ->
                ev.eventType == EventType.SHIFT &&
                shiftTitle.equalsIgnoreCase(ev.title) &&
                overlaps(ev.startDateTime, ev.endDateTime, rangeStart, rangeEnd)
        );

        int created = 0;

        for (LocalDate d = start; !d.isAfter(end); d = d.plusDays(1)) {

            // Team schedule: does the team work this day?
            boolean teamWorks;
            if (sched.type == ScheduleType.WEEKLY) {
                int idx = d.getDayOfWeek().getValue() - 1;
                teamWorks = (idx >= 0 && idx < 7 && sched.weeklyMask[idx]);
            } else {
                long delta = ChronoUnit.DAYS.between(sched.anchorDate, d);
                int cycle = Math.max(1, sched.cycleLengthDays);
                int dayIndex = (int)((delta + team.rotationOffsetDays) % cycle);
                if (dayIndex < 0) dayIndex += cycle;
                teamWorks = (dayIndex < Math.max(0, sched.onDays));
            }

            if (!teamWorks) continue;

            LocalDateTime shiftStart = LocalDateTime.of(d, sched.startTime);
            LocalDateTime shiftEnd;
            if (sched.endTime.equals(sched.startTime)) {
                shiftEnd = shiftStart.plusHours(8);
            } else if (sched.endTime.isAfter(sched.startTime)) {
                shiftEnd = LocalDateTime.of(d, sched.endTime);
            } else {
                shiftEnd = LocalDateTime.of(d.plusDays(1), sched.endTime);
            }

            for (Employee e : employees) {
                if (e.shiftTeamId == null || !e.shiftTeamId.equalsIgnoreCase(team.teamId)) continue;

                // Only schedule:
                // - FULL_TIME always
                // - TRADITIONAL only while on ORDERS (during that day)
                boolean eligible = (e.type == EmploymentType.FULL_TIME) || isTraditionalOnOrders(e, d);
                if (!eligible) continue;

                Event ev = new Event(nextEventId());
                ev.eventType = EventType.SHIFT;
                ev.title = shiftTitle;
                ev.notes = sched.name + (team.deployed || sched.deployed ? " | DEPLOYED" : "");
                ev.startDateTime = shiftStart;
                ev.endDateTime = shiftEnd;
                ev.employeeIdOrNull = e.employeeId;

                events.add(ev);
                created++;
            }
        }

        System.out.println("SUCCESS: Generated " + created + " SHIFT events for " + team.teamId + " in date range.");
    }

    // ============================================================
    // ============================================================
    // REMOVE TEAM SHIFTS FROM DATE RANGE
    // ============================================================
    // ============================================================
    void removeTeamShiftsMenu(Scanner sc) {
        listShiftTeams();
        String teamId = Input.readString(sc, "Team ID (blank cancels): ", true);
        if (teamId == null) return;

        ShiftTeam team = findShiftTeam(teamId);
        if (team == null) { System.out.println("ERROR: Team not found."); return; }

        LocalDate start = Input.readDate(sc, "Start Date yyyy-MM-dd (blank cancels): ", true);
        if (start == null) return;

        LocalDate end = Input.readDate(sc, "End Date yyyy-MM-dd (blank cancels): ", true);
        if (end == null) return;

        if (end.isBefore(start)) { System.out.println("ERROR: End date before start date."); return; }

        String shiftTitle = shiftTitleForTeam(team.teamId);
        LocalDateTime rangeStart = dayStart(start);
        LocalDateTime rangeEnd = dayEnd(end);

        int before = events.size();
        events.removeIf(ev ->
                ev.eventType == EventType.SHIFT &&
                shiftTitle.equalsIgnoreCase(ev.title) &&
                overlaps(ev.startDateTime, ev.endDateTime, rangeStart, rangeEnd)
        );
        int removed = before - events.size();

        System.out.println("SUCCESS: Removed " + removed + " SHIFT events.");
    }

    // ============================================================
    // ============================================================
    // EVENTS MENU (CREATE/EDIT/DELETE + CONFLICTS)
    // ============================================================
    // ============================================================
    void eventsMenu(Scanner sc) {
        while (true) {
            System.out.println("\n--- EVENTS ---");
            System.out.println("1) List Events for Employee (by Date)");
            System.out.println("2) List Global Events (by Date)");
            System.out.println("3) Create Event");
            System.out.println("4) Edit Event");
            System.out.println("5) Delete Event");
            System.out.println("6) Back");

            Integer c = Input.readInt(sc, "Choice: ", true);
            if (c == null) continue;

            if (c == 1) listEmployeeEventsByDate(sc);
            else if (c == 2) listGlobalEventsByDate(sc);
            else if (c == 3) createEvent(sc);
            else if (c == 4) editEvent(sc);
            else if (c == 5) deleteEvent(sc);
            else if (c == 6) return;
            else System.out.println("ERROR: Invalid choice.");
        }
    }

    void listEmployeeEventsByDate(Scanner sc) {
        System.out.println("\nEMPLOYEES");
        for (Employee e : employees) System.out.println(e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName);

        String empId = Input.readString(sc, "Employee ID (blank cancels): ", true);
        if (empId == null) return;

        if (findEmployee(empId) == null) { System.out.println("ERROR: Employee not found."); return; }

        LocalDate d = Input.readDate(sc, "Date yyyy-MM-dd (blank cancels): ", true);
        if (d == null) return;

        ArrayList<Event> evs = employeeEventsOnDate(empId, d);
        System.out.println("\nEvents for " + empId + " on " + d.format(DATE_FMT));
        if (evs.isEmpty()) { System.out.println("(None)"); return; }

        for (Event ev : evs) {
            System.out.println(ev.eventId + " | " + ev.eventType + " | " + ev.title +
                    " | " + ev.startDateTime + " -> " + ev.endDateTime);
        }
    }

    void listGlobalEventsByDate(Scanner sc) {
        LocalDate d = Input.readDate(sc, "Date yyyy-MM-dd (blank cancels): ", true);
        if (d == null) return;

        ArrayList<Event> evs = globalEventsOnDate(d);
        System.out.println("\nGlobal Events on " + d.format(DATE_FMT));
        if (evs.isEmpty()) { System.out.println("(None)"); return; }

        for (Event ev : evs) {
            System.out.println(ev.eventId + " | " + ev.eventType + " | " + ev.title +
                    " | " + ev.startDateTime + " -> " + ev.endDateTime);
        }
    }

    void createEvent(Scanner sc) {
        System.out.println("\nCreate Event");
        System.out.println("Event types include: APPOINTMENT, TRAINING, TDY, TEMPORARY_DUTY, LEAVE, IN_PROCESSING, OUT_PROCESSING, ORDERS, DEPLOYMENT, OTHER");
        System.out.println("SHIFT events are generated using schedules and teams.");

        String empId = Input.readString(sc, "Employee ID (blank for global / blank cancels): ", true);
        if (empId == null) return;
        if (!empId.isEmpty() && findEmployee(empId) == null) { System.out.println("ERROR: Employee not found."); return; }

        EventType type = Input.readEnum(sc, "Event Type (blank cancels): ", EventType.class, true);
        if (type == null) return;
        if (type == EventType.SHIFT || type == EventType.FEDERAL_HOLIDAY) { System.out.println("ERROR: Use generator for that."); return; }

        String title = Input.readString(sc, "Title (blank cancels): ", true);
        if (title == null) return;

        String notes = Input.readString(sc, "Notes (blank ok): ", false);

        LocalDate sd = Input.readDate(sc, "Start Date yyyy-MM-dd (blank cancels): ", true);
        if (sd == null) return;

        LocalTime st = Input.readTime(sc, "Start Time HH:mm (blank cancels): ", true);
        if (st == null) return;

        LocalDate ed = Input.readDate(sc, "End Date yyyy-MM-dd (blank cancels): ", true);
        if (ed == null) return;

        LocalTime et = Input.readTime(sc, "End Time HH:mm (blank cancels): ", true);
        if (et == null) return;

        LocalDateTime start = LocalDateTime.of(sd, st);
        LocalDateTime end = LocalDateTime.of(ed, et);
        if (!end.isAfter(start)) { System.out.println("ERROR: End must be after start."); return; }

        if (!empId.isEmpty()) {
            ArrayList<Event> conflicts = findNonShiftConflicts(empId, start, end, null);
            if (!conflicts.isEmpty()) {
                System.out.println("\nCONFLICTS FOUND (non-shift events):");
                for (Event c : conflicts) {
                    System.out.println(" - " + c.eventId + " | " + c.eventType + " | " + c.title + " | " + c.startDateTime + " -> " + c.endDateTime);
                }
                Boolean cont = Input.readYesNo(sc, "Continue scheduling anyway? (Y/N): ", false);
                if (cont == null || !cont) { System.out.println("CANCELLED."); return; }
            }

            Employee emp = findEmployee(empId);
            ShiftWindow win = expectedShiftWindow(emp, sd);
            if (win == null) {
                System.out.println("\nWARNING: No scheduled shift window for that employee on start date.");
                Boolean cont = Input.readYesNo(sc, "Continue anyway? (Y/N): ", false);
                if (cont == null || !cont) { System.out.println("CANCELLED."); return; }
            } else {
                if (!(start.isAfter(win.start) || start.isEqual(win.start)) || !(end.isBefore(win.end) || end.isEqual(win.end))) {
                    System.out.println("\nWARNING: Event time is outside expected shift window:");
                    System.out.println("Expected shift: " + win.start + " -> " + win.end);
                    Boolean cont = Input.readYesNo(sc, "Continue anyway? (Y/N): ", false);
                    if (cont == null || !cont) { System.out.println("CANCELLED."); return; }
                }
            }
        }

        Event ev = new Event(nextEventId());
        ev.eventType = type;
        ev.title = title;
        ev.notes = notes == null ? "" : notes;
        ev.startDateTime = start;
        ev.endDateTime = end;
        ev.employeeIdOrNull = empId;

        events.add(ev);
        System.out.println("SUCCESS: Created " + ev.eventId);
    }

    void editEvent(Scanner sc) {
        String id = Input.readString(sc, "Event ID to edit (blank cancels): ", true);
        if (id == null) return;

        Event ev = findEvent(id);
        if (ev == null) { System.out.println("ERROR: Not found."); return; }
        if (ev.eventType == EventType.FEDERAL_HOLIDAY) { System.out.println("ERROR: Holiday events should be regenerated, not edited."); return; }

        while (true) {
            System.out.println("\nEdit Event: " + ev.eventId + " | " + ev.eventType + " | " + ev.title);
            System.out.println("1) Type");
            System.out.println("2) Title");
            System.out.println("3) Notes");
            System.out.println("4) Start Date/Time");
            System.out.println("5) End Date/Time");
            System.out.println("6) Employee ID (blank for global)");
            System.out.println("7) Back");

            Integer c = Input.readInt(sc, "Choice: ", true);
            if (c == null) continue;

            if (c == 1) {
                EventType t = Input.readEnum(sc, "New Type (blank cancels): ", EventType.class, true);
                if (t != null && t != EventType.SHIFT && t != EventType.FEDERAL_HOLIDAY) ev.eventType = t;
            } else if (c == 2) {
                String v = Input.readString(sc, "New Title (blank cancels): ", true);
                if (v != null) ev.title = v;
            } else if (c == 3) {
                String v = Input.readString(sc, "New Notes (blank ok): ", false);
                ev.notes = (v == null ? "" : v);
            } else if (c == 4) {
                LocalDate sd = Input.readDate(sc, "Start Date yyyy-MM-dd (blank cancels): ", true);
                if (sd == null) continue;
                LocalTime st = Input.readTime(sc, "Start Time HH:mm (blank cancels): ", true);
                if (st == null) continue;
                LocalDateTime start = LocalDateTime.of(sd, st);
                if (!ev.endDateTime.isAfter(start)) { System.out.println("ERROR: End must be after start."); continue; }
                if (!ev.isGlobal()) {
                    ArrayList<Event> conflicts = findNonShiftConflicts(ev.employeeIdOrNull, start, ev.endDateTime, ev.eventId);
                    if (!conflicts.isEmpty() && ev.eventType != EventType.SHIFT) {
                        System.out.println("\nCONFLICTS FOUND:");
                        for (Event x : conflicts) System.out.println(" - " + x.eventId + " | " + x.eventType + " | " + x.title);
                        Boolean cont = Input.readYesNo(sc, "Continue anyway? (Y/N): ", false);
                        if (cont == null || !cont) continue;
                    }
                }
                ev.startDateTime = start;
            } else if (c == 5) {
                LocalDate ed = Input.readDate(sc, "End Date yyyy-MM-dd (blank cancels): ", true);
                if (ed == null) continue;
                LocalTime et = Input.readTime(sc, "End Time HH:mm (blank cancels): ", true);
                if (et == null) continue;
                LocalDateTime end = LocalDateTime.of(ed, et);
                if (!end.isAfter(ev.startDateTime)) { System.out.println("ERROR: End must be after start."); continue; }
                if (!ev.isGlobal()) {
                    ArrayList<Event> conflicts = findNonShiftConflicts(ev.employeeIdOrNull, ev.startDateTime, end, ev.eventId);
                    if (!conflicts.isEmpty() && ev.eventType != EventType.SHIFT) {
                        System.out.println("\nCONFLICTS FOUND:");
                        for (Event x : conflicts) System.out.println(" - " + x.eventId + " | " + x.eventType + " | " + x.title);
                        Boolean cont = Input.readYesNo(sc, "Continue anyway? (Y/N): ", false);
                        if (cont == null || !cont) continue;
                    }
                }
                ev.endDateTime = end;
            } else if (c == 6) {
                String empId = Input.readString(sc, "Employee ID (blank for global / blank cancels): ", true);
                if (empId == null) continue;
                if (!empId.isEmpty() && findEmployee(empId) == null) { System.out.println("ERROR: Employee not found."); continue; }

                if (!empId.isEmpty()) {
                    ArrayList<Event> conflicts = findNonShiftConflicts(empId, ev.startDateTime, ev.endDateTime, ev.eventId);
                    if (!conflicts.isEmpty() && ev.eventType != EventType.SHIFT) {
                        System.out.println("\nCONFLICTS FOUND:");
                        for (Event x : conflicts) System.out.println(" - " + x.eventId + " | " + x.eventType + " | " + x.title);
                        Boolean cont = Input.readYesNo(sc, "Continue anyway? (Y/N): ", false);
                        if (cont == null || !cont) continue;
                    }
                }

                ev.employeeIdOrNull = empId;
            } else if (c == 7) {
                return;
            } else {
                System.out.println("ERROR: Invalid choice.");
            }
        }
    }

    void deleteEvent(Scanner sc) {
        String id = Input.readString(sc, "Event ID to delete (blank cancels): ", true);
        if (id == null) return;

        Event ev = findEvent(id);
        if (ev == null) { System.out.println("ERROR: Not found."); return; }
        if (ev.eventType == EventType.FEDERAL_HOLIDAY) { System.out.println("ERROR: Holiday events are auto-managed."); return; }

        events.remove(ev);
        System.out.println("SUCCESS: Deleted.");
    }

    // ============================================================
    // ============================================================
    // DRILL MENU
    // ============================================================
    // ============================================================
    void drillMenu(Scanner sc) {
        while (true) {
            System.out.println("\n--- DRILL ---");
            System.out.println("1) View Drill/Alt Drill for Date");
            System.out.println("2) Add Drill Day");
            System.out.println("3) Add Alternate Drill Day");
            System.out.println("4) Delete Drill/Alt Drill on Date");
            System.out.println("5) Set Traditional Drill Availability");
            System.out.println("6) View Drill Availability for Date");
            System.out.println("7) Back");

            Integer c = Input.readInt(sc, "Choice: ", true);
            if (c == null) continue;

            if (c == 1) viewDrillOnDate(sc);
            else if (c == 2) addAllDayGlobal(sc, EventType.DRILL_DAY, "DRILL DAY");
            else if (c == 3) addAllDayGlobal(sc, EventType.ALT_DRILL_DAY, "ALT DRILL DAY");
            else if (c == 4) deleteDrillOnDate(sc);
            else if (c == 5) setDrillAvailability(sc);
            else if (c == 6) viewDrillAvailability(sc);
            else if (c == 7) return;
            else System.out.println("ERROR: Invalid choice.");
        }
    }

    void viewDrillOnDate(Scanner sc) {
        LocalDate d = Input.readDate(sc, "Date yyyy-MM-dd (blank cancels): ", true);
        if (d == null) return;

        ArrayList<Event> evs = globalEventsOnDate(d);
        boolean any = false;
        for (Event ev : evs) {
            if (ev.eventType == EventType.DRILL_DAY || ev.eventType == EventType.ALT_DRILL_DAY) {
                System.out.println(ev.eventId + " | " + ev.eventType + " | " + ev.title);
                any = true;
            }
        }
        if (!any) System.out.println("(No drill events for that date)");
    }

    void addAllDayGlobal(Scanner sc, EventType type, String title) {
        LocalDate d = Input.readDate(sc, "Date yyyy-MM-dd (blank cancels): ", true);
        if (d == null) return;

        for (Event ev : events) {
            if (ev.isGlobal() && ev.eventType == type && ev.startDateTime.toLocalDate().equals(d)) {
                System.out.println("ERROR: Already exists for that date.");
                return;
            }
        }

        Event ev = new Event(nextEventId());
        ev.eventType = type;
        ev.title = title;
        ev.notes = "";
        ev.startDateTime = dayStart(d);
        ev.endDateTime = dayEnd(d);
        ev.employeeIdOrNull = "";

        events.add(ev);
        System.out.println("SUCCESS: Added " + type + " on " + d.format(DATE_FMT));
    }

    void deleteDrillOnDate(Scanner sc) {
        LocalDate d = Input.readDate(sc, "Date yyyy-MM-dd (blank cancels): ", true);
        if (d == null) return;

        int before = events.size();
        events.removeIf(ev -> ev.isGlobal() &&
                (ev.eventType == EventType.DRILL_DAY || ev.eventType == EventType.ALT_DRILL_DAY) &&
                ev.startDateTime.toLocalDate().equals(d));

        int removed = before - events.size();
        System.out.println("Removed: " + removed);
    }

    void setDrillAvailability(Scanner sc) {
        System.out.println("\nTRADITIONAL EMPLOYEES");
        for (Employee e : employees) if (e.type == EmploymentType.TRADITIONAL)
            System.out.println(e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName);

        String empId = Input.readString(sc, "Employee ID (blank cancels): ", true);
        if (empId == null) return;

        Employee e = findEmployee(empId);
        if (e == null) { System.out.println("ERROR: Not found."); return; }
        if (e.type != EmploymentType.TRADITIONAL) { System.out.println("ERROR: Employee is not TRADITIONAL."); return; }

        LocalDate d = Input.readDate(sc, "Drill Date yyyy-MM-dd (blank cancels): ", true);
        if (d == null) return;

        Boolean avail = Input.readYesNo(sc, "Available? (Y/N) (blank cancels): ", true);
        if (avail == null) return;

        for (DrillAvailability da : drillAvailabilityList) {
            if (da.employeeId.equalsIgnoreCase(empId) && da.drillDate.equals(d)) {
                da.available = avail;
                System.out.println("SUCCESS: Updated.");
                return;
            }
        }

        drillAvailabilityList.add(new DrillAvailability(empId, d, avail));
        System.out.println("SUCCESS: Added.");
    }

    void viewDrillAvailability(Scanner sc) {
        LocalDate d = Input.readDate(sc, "Drill Date yyyy-MM-dd (blank cancels): ", true);
        if (d == null) return;

        System.out.println("\nAvailability for " + d.format(DATE_FMT));
        for (Employee e : employees) {
            if (e.type != EmploymentType.TRADITIONAL) continue;

            DrillAvailability found = null;
            for (DrillAvailability da : drillAvailabilityList) {
                if (da.employeeId.equalsIgnoreCase(e.employeeId) && da.drillDate.equals(d)) { found = da; break; }
            }

            String status = (found == null) ? "(not set)" : (found.available ? "AVAILABLE" : "NOT AVAILABLE");
            System.out.println(e.employeeId + " | " + e.rank + " " + e.lastName + " | " + status);
        }
    }

    // ============================================================
    // ============================================================
    // VIEWS MENU
    // ============================================================
    // ============================================================
    void viewsMenu(Scanner sc) {
        while (true) {
            System.out.println("\n--- VIEWS ---");
            System.out.println("1) Daily View (all employees)");
            System.out.println("2) Weekly View (summary)");
            System.out.println("3) Monthly View (counts)");
            System.out.println("4) Hourly View (single employee)");
            System.out.println("5) Shift Coverage View (teams on a date)");
            System.out.println("6) Back");

            Integer c = Input.readInt(sc, "Choice: ", true);
            if (c == null) continue;

            if (c == 1) dailyView(sc);
            else if (c == 2) weeklyView(sc);
            else if (c == 3) monthlyView(sc);
            else if (c == 4) hourlyView(sc);
            else if (c == 5) shiftCoverageView(sc);
            else if (c == 6) return;
            else System.out.println("ERROR: Invalid choice.");
        }
    }

    void dailyView(Scanner sc) {
        LocalDate d = Input.readDate(sc, "Date yyyy-MM-dd (blank cancels): ", true);
        if (d == null) return;

        System.out.println("\n=== DAILY VIEW: " + d.format(DATE_FMT) + " ===");

        ArrayList<Event> globals = globalEventsOnDate(d);
        if (!globals.isEmpty()) {
            System.out.println("\nGlobal:");
            for (Event ev : globals) System.out.println(" - " + ev.eventType + " | " + ev.title);
        }

        for (Employee e : employees) {
            System.out.println("\n" + e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName);

            ArrayList<Event> evs = employeeEventsOnDate(e.employeeId, d);
            if (evs.isEmpty()) { System.out.println(" (No events)"); continue; }

            for (Event ev : evs) {
                System.out.println(" - " + ev.eventType + " | " + ev.title + " | " + ev.startDateTime.toLocalTime() + " -> " + ev.endDateTime.toLocalTime() + " | " + ev.eventId);
            }
        }
    }

    void weeklyView(Scanner sc) {
        LocalDate d = Input.readDate(sc, "Any date in week yyyy-MM-dd (blank cancels): ", true);
        if (d == null) return;

        LocalDate monday = d.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY));
        LocalDate[] days = new LocalDate[7];
        for (int i = 0; i < 7; i++) days[i] = monday.plusDays(i);

        System.out.println("\n=== WEEKLY VIEW (Mon..Sun) starting " + monday.format(DATE_FMT) + " ===");
        System.out.println("Legend: H=Holiday  D=Drill  E=Event  S=Shift  .=None");

        StringBuilder header = new StringBuilder("EMPLOYEE ");
        for (int i = 0; i < 7; i++) header.append(" ").append(days[i].getDayOfWeek().toString().substring(0, 2));
        System.out.println(header);

        for (Employee e : employees) {
            StringBuilder row = new StringBuilder();
            row.append(String.format("%-8s", e.employeeId));

            for (int i = 0; i < 7; i++) {
                LocalDate day = days[i];

                boolean holiday = false;
                boolean drill = false;
                for (Event ge : globalEventsOnDate(day)) {
                    if (ge.eventType == EventType.FEDERAL_HOLIDAY) holiday = true;
                    if (ge.eventType == EventType.DRILL_DAY || ge.eventType == EventType.ALT_DRILL_DAY) drill = true;
                }

                boolean hasShift = hasShiftEventOnDate(e.employeeId, day);

                boolean hasEvent = false;
                for (Event ev : employeeEventsOnDate(e.employeeId, day)) {
                    if (ev.eventType != EventType.SHIFT) { hasEvent = true; break; }
                }

                char marker = '.';
                if (holiday) marker = 'H';
                else if (drill) marker = 'D';
                else if (hasEvent) marker = 'E';
                else if (hasShift) marker = 'S';

                row.append("  ").append(marker);
            }
            System.out.println(row);
        }
    }

    void monthlyView(Scanner sc) {
        String ym = Input.readString(sc, "Month yyyy-MM (blank cancels): ", true);
        if (ym == null) return;

        YearMonth m;
        try { m = YearMonth.parse(ym); }
        catch (Exception ex) { System.out.println("ERROR: Must be yyyy-MM"); return; }

        LocalDate start = m.atDay(1);
        LocalDate end = m.atEndOfMonth();

        System.out.println("\n=== MONTHLY COUNTS: " + m + " ===");

        for (Employee e : employees) {
            int shiftDays = 0;
            int eventDays = 0;
            int leaveDays = 0;

            for (LocalDate d = start; !d.isAfter(end); d = d.plusDays(1)) {
                boolean hasShift = hasShiftEventOnDate(e.employeeId, d);

                boolean hasNonShift = false;
                boolean hasLeave = false;
                for (Event ev : employeeEventsOnDate(e.employeeId, d)) {
                    if (ev.eventType == EventType.SHIFT) continue;
                    hasNonShift = true;
                    if (ev.eventType == EventType.LEAVE) hasLeave = true;
                }

                if (hasShift) shiftDays++;
                if (hasNonShift) eventDays++;
                if (hasLeave) leaveDays++;
            }

            System.out.println(e.employeeId + " | " + e.rank + " " + e.lastName +
                    " | ShiftDays=" + shiftDays + " | EventDays=" + eventDays + " | LeaveDays=" + leaveDays);
        }
    }

    void hourlyView(Scanner sc) {
        System.out.println("\nEMPLOYEES");
        for (Employee e : employees) System.out.println(e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName);

        String empId = Input.readString(sc, "Employee ID (blank cancels): ", true);
        if (empId == null) return;

        if (findEmployee(empId) == null) { System.out.println("ERROR: Employee not found."); return; }

        LocalDate d = Input.readDate(sc, "Date yyyy-MM-dd (blank cancels): ", true);
        if (d == null) return;

        System.out.println("\n=== HOURLY VIEW: " + empId + " on " + d.format(DATE_FMT) + " ===");

        LocalDateTime base = dayStart(d);
        for (int h = 0; h < 24; h++) {
            LocalDateTime hs = base.plusHours(h);
            LocalDateTime he = base.plusHours(h + 1);

            Event bestNonShift = null;
            boolean inShift = false;

            for (Event ev : events) {
                if (ev.employeeIdOrNull == null || ev.employeeIdOrNull.trim().isEmpty()) continue;
                if (!ev.employeeIdOrNull.equalsIgnoreCase(empId)) continue;
                if (!overlaps(ev.startDateTime, ev.endDateTime, hs, he)) continue;

                if (ev.eventType == EventType.SHIFT) inShift = true;
                else if (bestNonShift == null) bestNonShift = ev;
            }

            String label;
            if (bestNonShift != null) label = bestNonShift.eventType + " | " + bestNonShift.title;
            else if (inShift) label = "SHIFT";
            else label = "";

            System.out.println(String.format("%02d:00-%02d:00 | %s", h, h + 1, label));
        }
    }

    void shiftCoverageView(Scanner sc) {
        LocalDate d = Input.readDate(sc, "Date yyyy-MM-dd (blank cancels): ", true);
        if (d == null) return;

        System.out.println("\n=== SHIFT COVERAGE: " + d.format(DATE_FMT) + " ===");

        LocalDateTime s = dayStart(d);
        LocalDateTime e = dayEnd(d);

        HashMap<String, ArrayList<String>> teamToEmployees = new HashMap<>();

        for (Event ev : events) {
            if (ev.eventType != EventType.SHIFT) continue;
            if (ev.employeeIdOrNull == null || ev.employeeIdOrNull.trim().isEmpty()) continue;
            if (!overlaps(ev.startDateTime, ev.endDateTime, s, e)) continue;

            String team = ev.title == null ? "SHIFT" : ev.title;
            teamToEmployees.putIfAbsent(team, new ArrayList<>());
            teamToEmployees.get(team).add(ev.employeeIdOrNull);
        }

        if (teamToEmployees.isEmpty()) {
            System.out.println("(No shift events found for that date)");
            return;
        }

        for (String team : teamToEmployees.keySet()) {
            System.out.println("\n" + team);
            ArrayList<String> emps = teamToEmployees.get(team);
            emps.sort(String::compareToIgnoreCase);
            for (String empId : emps) {
                Employee emp = findEmployee(empId);
                String name = (emp == null) ? "" : (" | " + emp.rank + " " + emp.lastName);
                System.out.println(" - " + empId + name);
            }
        }
    }

    // ============================================================
    // ============================================================
    // REPORTS
    // ============================================================
    // ============================================================
    void reportDutyCounts() {
        System.out.println("\n=== DUTY COUNTS BY SECTION ===");

        if (sections.isEmpty()) { System.out.println("(No sections)"); return; }

        for (Section sec : sections) {
            System.out.println("\n" + formatSectionChain(sec.sectionId));

            if (sec.dutyNames.isEmpty()) {
                System.out.println(" (No duties defined)");
                continue;
            }

            for (String duty : sec.dutyNames) {
                int count = 0;
                for (Employee e : employees) {
                    for (DutyAssign a : e.dutyAssignments) {
                        if (a.sectionId.equalsIgnoreCase(sec.sectionId) && a.dutyName.equalsIgnoreCase(duty)) count++;
                    }
                }
                System.out.println(" - " + duty + " | Count=" + count);
            }
        }
    }

    void reportDutiesByEmployee() {
        System.out.println("\n=== DUTIES BY EMPLOYEE ===");

        if (employees.isEmpty()) { System.out.println("(No employees)"); return; }

        for (Employee e : employees) {
            System.out.println("\n" + e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName);

            if (e.dutyAssignments.isEmpty()) {
                System.out.println(" (No duties assigned)");
                continue;
            }

            for (DutyAssign a : e.dutyAssignments) {
                System.out.println(" - " + formatSectionChain(a.sectionId) + " => " + a.dutyName);
            }
        }
    }

    void reportWhoHoldsDuty(Scanner sc) {
        if (sections.isEmpty()) { System.out.println("ERROR: No sections."); return; }

        System.out.println("\nSECTIONS");
        for (Section s : sections) System.out.println(s.sectionId + " | " + s.name);

        String secId = Input.readString(sc, "Section ID (blank cancels): ", true);
        if (secId == null) return;

        Section sec = findSection(secId);
        if (sec == null) { System.out.println("ERROR: Section not found."); return; }

        if (sec.dutyNames.isEmpty()) { System.out.println("ERROR: No duties defined for that section."); return; }

        System.out.println("Duties:");
        for (String d : sec.dutyNames) System.out.println(" - " + d);

        String duty = Input.readString(sc, "Duty Name (exact) (blank cancels): ", true);
        if (duty == null) return;

        if (!sectionHasDuty(secId, duty)) { System.out.println("ERROR: Duty not defined for that section."); return; }

        System.out.println("\n=== PEOPLE HOLDING DUTY: " + duty + " (" + secId + ") ===");

        boolean any = false;
        for (Employee e : employees) {
            for (DutyAssign a : e.dutyAssignments) {
                if (a.sectionId.equalsIgnoreCase(secId) && a.dutyName.equalsIgnoreCase(duty)) {
                    System.out.println(" - " + e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName);
                    any = true;
                }
            }
        }

        if (!any) System.out.println("(None assigned)");
    }

    void reportRaters() {
        System.out.println("\n=== RATER / RATEE REPORT ===");

        HashMap<String, ArrayList<Employee>> raterToRatees = new HashMap<>();
        for (Employee e : employees) {
            if (e.raterEmployeeId == null || e.raterEmployeeId.trim().isEmpty()) continue;
            raterToRatees.putIfAbsent(e.raterEmployeeId, new ArrayList<>());
            raterToRatees.get(e.raterEmployeeId).add(e);
        }

        if (raterToRatees.isEmpty()) {
            System.out.println("(No rater assignments)");
            return;
        }

        for (String raterId : raterToRatees.keySet()) {
            Employee r = findEmployee(raterId);
            String rName = (r == null) ? "" : (" | " + r.rank + " " + r.lastName + ", " + r.firstName);

            System.out.println("\nRater: " + raterId + rName);
            ArrayList<Employee> ratees = raterToRatees.get(raterId);
            ratees.sort(Comparator.comparing(x -> x.lastName));

            for (Employee ratee : ratees) {
                System.out.println(" - " + ratee.employeeId + " | " + ratee.rank + " " + ratee.lastName + ", " + ratee.firstName);
            }
        }
    }

    // ============================================================
    // ============================================================
    // AVAILABILITY DASHBOARD
    // ============================================================
    // ============================================================
    void availabilityDashboard(Scanner sc) {
        LocalDate d = Input.readDate(sc, "Date yyyy-MM-dd (blank cancels): ", true);
        if (d == null) return;

        System.out.println("\n=== AVAILABILITY DASHBOARD: " + d.format(DATE_FMT) + " ===");

        ArrayList<Event> globals = globalEventsOnDate(d);
        if (!globals.isEmpty()) {
            System.out.println("Global:");
            for (Event g : globals) System.out.println(" - " + g.eventType + " | " + g.title);
        }

        int onShift = 0, leave = 0, tdy = 0, training = 0, appointment = 0, other = 0, available = 0;

        for (Employee e : employees) {
            String status = "AVAILABLE";
            LocalDateTime ds = dayStart(d);
            LocalDateTime de = dayEnd(d);

            ArrayList<Event> evs = employeeEventsOnDate(e.employeeId, d);

            boolean hasShift = false;
            for (Event ev : evs) if (ev.eventType == EventType.SHIFT) hasShift = true;

            // Priority statuses (non-shift override shift)
            if (hasType(evs, EventType.LEAVE)) status = "LEAVE";
            else if (hasType(evs, EventType.TDY)) status = "TDY";
            else if (hasType(evs, EventType.DEPLOYMENT)) status = "DEPLOYMENT";
            else if (hasType(evs, EventType.TRAINING)) status = "TRAINING";
            else if (hasType(evs, EventType.APPOINTMENT)) status = "APPOINTMENT";
            else if (hasType(evs, EventType.TEMPORARY_DUTY)) status = "TEMP DUTY";
            else if (hasType(evs, EventType.IN_PROCESSING)) status = "IN-PROC";
            else if (hasType(evs, EventType.OUT_PROCESSING)) status = "OUT-PROC";
            else if (hasType(evs, EventType.ORDERS) && e.type == EmploymentType.TRADITIONAL) status = "ON ORDERS";
            else if (hasShift) status = "ON SHIFT";
            else if (e.type == EmploymentType.TRADITIONAL) status = "TRADITIONAL (NOT SCHEDULED)";

            System.out.println(e.employeeId + " | " + e.rank + " " + e.lastName + ", " + e.firstName + " | " + status);

            if (status.equals("ON SHIFT")) onShift++;
            else if (status.equals("LEAVE")) leave++;
            else if (status.equals("TDY")) tdy++;
            else if (status.equals("TRAINING")) training++;
            else if (status.equals("APPOINTMENT")) appointment++;
            else if (status.equals("AVAILABLE")) available++;
            else other++;
        }

        System.out.println("\nCounts:");
        System.out.println("ON SHIFT=" + onShift);
        System.out.println("LEAVE=" + leave);
        System.out.println("TDY=" + tdy);
        System.out.println("TRAINING=" + training);
        System.out.println("APPOINTMENT=" + appointment);
        System.out.println("AVAILABLE=" + available);
        System.out.println("OTHER=" + other);
    }

    boolean hasType(ArrayList<Event> evs, EventType t) {
        for (Event ev : evs) if (ev.eventType == t) return true;
        return false;
    }

    // ============================================================
    // ============================================================
    // FEDERAL HOLIDAYS (AUTO GENERATION)
    // ============================================================
    // ============================================================
    void ensureFederalHolidaysForYear(int year) {
        ArrayList<Holiday> holidays = new ArrayList<>();

        holidays.add(new Holiday("New Year's Day", observed(LocalDate.of(year, 1, 1))));
        holidays.add(new Holiday("Martin Luther King Jr. Day", nthWeekdayOfMonth(year, 1, DayOfWeek.MONDAY, 3)));
        holidays.add(new Holiday("Washington's Birthday", nthWeekdayOfMonth(year, 2, DayOfWeek.MONDAY, 3)));
        holidays.add(new Holiday("Memorial Day", lastWeekdayOfMonth(year, 5, DayOfWeek.MONDAY)));
        holidays.add(new Holiday("Juneteenth National Independence Day", observed(LocalDate.of(year, 6, 19))));
        holidays.add(new Holiday("Independence Day", observed(LocalDate.of(year, 7, 4))));
        holidays.add(new Holiday("Labor Day", nthWeekdayOfMonth(year, 9, DayOfWeek.MONDAY, 1)));
        holidays.add(new Holiday("Columbus Day", nthWeekdayOfMonth(year, 10, DayOfWeek.MONDAY, 2)));
        holidays.add(new Holiday("Veterans Day", observed(LocalDate.of(year, 11, 11))));
        holidays.add(new Holiday("Thanksgiving Day", nthWeekdayOfMonth(year, 11, DayOfWeek.THURSDAY, 4)));
        holidays.add(new Holiday("Christmas Day", observed(LocalDate.of(year, 12, 25))));

        for (Holiday h : holidays) {
            LocalDate d = h.date;

            boolean exists = false;
            for (Event ev : events) {
                if (!ev.isGlobal()) continue;
                if (ev.eventType != EventType.FEDERAL_HOLIDAY) continue;
                if (!ev.startDateTime.toLocalDate().equals(d)) continue;
                if (ev.title != null && ev.title.toLowerCase().contains(h.name.toLowerCase())) { exists = true; break; }
            }
            if (exists) continue;

            Event ev = new Event(nextEventId());
            ev.eventType = EventType.FEDERAL_HOLIDAY;
            ev.title = "Federal Holiday - " + h.name;
            ev.notes = "";
            ev.startDateTime = dayStart(d);
            ev.endDateTime = dayEnd(d);
            ev.employeeIdOrNull = "";

            events.add(ev);
        }
    }

    static class Holiday {
        String name;
        LocalDate date;
        Holiday(String n, LocalDate d) { name = n; date = d; }
    }

    LocalDate observed(LocalDate d) {
        DayOfWeek dow = d.getDayOfWeek();
        if (dow == DayOfWeek.SATURDAY) return d.minusDays(1);
        if (dow == DayOfWeek.SUNDAY) return d.plusDays(1);
        return d;
    }

    LocalDate nthWeekdayOfMonth(int year, int month, DayOfWeek dow, int nth) {
        LocalDate first = LocalDate.of(year, month, 1);
        LocalDate day = first.with(TemporalAdjusters.nextOrSame(dow));
        return day.plusWeeks(nth - 1);
    }

    LocalDate lastWeekdayOfMonth(int year, int month, DayOfWeek dow) {
        LocalDate last = LocalDate.of(year, month, 1).with(TemporalAdjusters.lastDayOfMonth());
        return last.with(TemporalAdjusters.previousOrSame(dow));
    }
}
